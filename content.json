[{"title":"计算几何：凸包","date":"2019-04-05T07:33:17.000Z","path":"2019/04/05/计算几何：凸包/","text":"对于初学计算几何的OIer来说，Graham算法是个不错的凸包算法。Graham算法相比极角排序法来说，更为直观也更容易理解。 数据定义12345678910111213141516171819202122232425262728293031323334353637383940class Point &#123;public: double x, y; Point(double x = 0, double y = 0):x(x), y(y) &#123;&#125; Point(Point a, Point b) &#123; //构造从a到b的向量 x = b.x - a.x; y = b.y - a.y; &#125; double dist(const Point&amp; p) const &#123; //计算从自身到点P的距离 return sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y)); &#125; double operator * (const Point&amp; p) const &#123; //计算向量叉积 return x * p.y - p.x * y; &#125; bool operator &lt; (const Point&amp; p) const &#123; //按照X轴排序 return (x == p.x) ? (y &lt; p.y) : (x &lt; p.x); &#125; friend istream&amp; operator &gt;&gt; (istream&amp; in, Point&amp; p) &#123; //重载 &gt;&gt; 运算符使得cin可以输入 in &gt;&gt; p.x &gt;&gt; p.y; return in; &#125;&#125;;const int MAXN = 10000 + 5;Point p[MAXN];int st[MAXN], top = -1; //点栈int n; 主程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void input() &#123; //输入所有点 cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; p[i]; &#125;&#125;int main() &#123; input(); sort(p, p + n); //对点进行直角坐标排序􏰣􏰳􏰣􏰳􏰮􏰂 double ans = 0; st[++top] = 0; //将第一个点入栈 st[++top] = 1; //将第二个点入栈 for(int i = 2; i &lt; n; i++) &#123; Point u(p[st[top - 1]], p[st[top]]); //计算栈顶两个点构成的向量 Point v(p[st[top]], p[i]); //计算当前点与栈顶构成的向量 while(u * v &lt; 0) &#123; //若叉积小于0 if(top == 0) &#123; //当栈中只有一个元素时，退出循环 break; &#125; top--; //弹出栈顶 u = Point(p[st[top - 1]], p[st[top]]); //更新 v = Point(p[st[top]], p[i]); //更新 &#125; st[++top] = i; //将第i个点压入栈中 &#125; for(int i = 0; i &lt;= top - 1; i++) &#123; ans += p[st[i]].dist(p[st[i + 1]]); //累加下半个凸包的长度 &#125; top = -1; //清空栈 //求出上半个凸包，与前半部分大同小异 st[++top] = 0; st[++top] = 1; for(int i = 2; i &lt; n; i++) &#123; Point u(p[st[top - 1]], p[st[top]]); Point v(p[st[top]], p[i]); while(u * v &gt; 0) &#123; if(top == 0) &#123; break; &#125; top--; u = Point(p[st[top - 1]], p[st[top]]); v = Point(p[st[top]], p[i]); &#125; st[++top] = i; &#125; for(int i = 0; i &lt;= top - 1; i++) &#123; ans += p[st[i]].dist(p[st[i + 1]]); &#125; top = -1; cout &lt;&lt; setprecision(2) &lt;&lt; fixed &lt;&lt; ans &lt;&lt; endl; //控制精度 return 0;&#125;","tags":[]},{"title":"Splay学习笔记","date":"2019-03-28T12:59:43.000Z","path":"2019/03/28/Splay学习笔记/","text":"前言伸展树（英语：Splay Tree）是一种能够自我平衡的二叉查找树，它能在均摊O(log n)的时间内完成基于伸展（Splay）操作的插入、查找、修改和删除操作。 定义节点node.v：节点node的值 node.father：节点node的父节点 node.ch[0]与node.ch[1]：节点node的左子节点与右子节点 node.size：以节点node为根节点的子树的节点总数 node.cnt：数值与节点node相同的节点的数量（都储存在节点node中） 代码：12345678class Node &#123;public: int v, father, ch[2], size, cnt; Node(int v = 0, int father = 0, int size = 0, int cnt = 0):v(v), father(father), size(size), cnt(cnt) &#123; ch[0] = ch[1] = 0; &#125;&#125;; 树root：根节点 cnt：总结点数 12Node node[MAXN];int root = 0, cnt = 0; 操作基本操作pushuppushup()函数：更新节点p的size值 123void pushup(int p) &#123; node[p].size = node[node[p].ch[0]].size + node[p].cnt + node[node[p].ch[1]].size; //节点数 = 左子树节点数 + 本身的节点数 + 右子树节点数&#125; checkcheck()函数：询问节点p是其父节点的左子节点还是右子节点 123int check(int p) &#123; return node[node[p].father].ch[0] == p ? 0 : 1; //0代表左子节点，1代表右子节点&#125; connectconnect()函数：将节点x连接为节点f的子节点，方向为d (d = 0, 1，同上) 1234void connect(int x, int f, int d) &#123; node[f].ch[d] = x; //将节点f的子节点设置为x node[x].father = f; //将节点x的父节点设置为f&#125; 旋转rotate旋转是平衡树最主要的操作，其本质在于，每次进行旋转时，左右子树当中之一高度 -1，另外一棵高度 +1，以达到平衡的目的。 左旋： 第一次连边，节点x的子节点成为x的父节点的右子节点 第二次连边，节点x成为节点x的父节点的父节点的子节点，方向与x的父节点相同 第三次连边，节点x的父节点成为节点x的左子节点 右旋： 第一次连边，节点x的子节点成为x的父节点的左子节点 第二次连边，节点x成为节点x的父节点的父节点的子节点，方向与x的父节点相同 第三次连边，节点x的父节点成为节点x的右子节点 旋转操作只与标为红，蓝，绿的三个部分有关。 12345678void rotate(int x) &#123; int y = node[x].father, z = node[y].father, d = check(x), w = node[x].ch[d ^ 1]; //w判断应该左旋还是右旋 connect(w, y, d); //第一次连边，节点x的子节点连接到x的父节点，方向与节点x相同 connect(x, z, check(y)); //第二次连边，节点x连接到节点x的父节点的父节点，方向与x的父节点相同 connect(y, x, d ^ 1); //第三次连边，节点x的父节点连接到节点x，方向与节点x原先的方向相反 pushup(y); //更新子树 pushup(x); //更新子树&#125; 伸展splaySplay操作：将节点x旋转到节点dist的子节点。通常是将该节点旋转到根节点，在这种情况下，应当将root置为x 最朴素的想法：只要父节点不是dist就一直旋转该节点，但这样很容易被某些机（wu）智（liang）出题人卡。 12345678void splay(int x, int dist = 0) &#123; while(node[x].father != dist) &#123; rotate(x); &#125; if(dist == 0) &#123; root = x; &#125;&#125; 所以，在实际操作中，通常会预判节点x的父节点的方向，若方向一致则旋转其父节点，减少被卡的可能性。 1234567891011121314void splay(int x, int dist = 0) &#123; for(int f = node[x].father; f = node[x].father, f != dist; rotate(x)) &#123; if(node[f].father != dist) &#123; if(check(x) == check(f)) &#123; rotate(f); //方向一致则旋转x的父节点 &#125; else &#123; rotate(x); //方向不一致则旋转x &#125; &#125; &#125; if(dist == 0) &#123; root = x; &#125;&#125; 查找find查找值为x的节点，找到后将其置为root以便操作。 find操作的意义在于将值为x的节点伸展（splay）到根，在不存在值为x的节点的情况下，应将小于x的节点中最大的节点伸展（splay）到根。 1234567void find(int x) &#123; int cur = root; while(node[cur].ch[x &gt; node[cur].v] != 0 &amp;&amp; x != node[cur].v) &#123; cur = node[cur].ch[x &gt; node[cur].v]; //查找值为x的节点 &#125; splay(cur);&#125; 公共操作如果将本文讲的Splay打包成一个class，则前文所述的操作应包含在private中，本节所述的操作应包含在public中。 insertSplay中的insert其实与朴素BST中的insert没有什么区别，但若直接插入可能导致树退化为链，所以要在末尾处调用一次splay()函数，使Splay树保持平衡。 1234567891011121314151617void insert(int x) &#123; int cur = root, p = 0; while(cur != 0 &amp;&amp; node[cur].v != x) &#123; p = cur; cur = node[cur].ch[x &lt; node[cur].v ? 0 : 1]; &#125; if(cur != 0) &#123; node[cur].cnt++; &#125; else &#123; cur = ++cnt; if(p != 0) &#123; node[p].ch[x &lt;= node[p].v ? 0 : 1] = cur; &#125; node[cur] = Node(x, p, 1, 1); &#125; splay(cur);&#125; serialserial操作：查询值为x的节点，在find操作的基础上，serial只需要在find过后输出左子树节点数量即可。 1234int serial(int x) &#123; find(x); return node[node[root].ch[0]].size&#125; pre找出值为x的节点的前驱，将节点splay到root后在左子树查找最大值即可。 1234567891011int pre(int x) &#123; find(x); if(node[root].v &lt; x) &#123; return root; &#125; int cur = node[root].ch[0]; while(node[cur].ch[1] != 0) &#123; cur = node[cur].ch[1]; &#125; return cur;&#125; suc找出值为x的点的后继，与前驱同理。 1234567891011int suc(int x) &#123; find(x); if(node[root].v &gt; x) &#123; return root; &#125; int cur = node[root].ch[1]; while(node[cur].ch[0] != 0) &#123; cur = node[cur].ch[0]; &#125; return cur;&#125; remove删除一个节点。 删除较为复杂，分四步来完成： 定义last为节点的前驱，next为节点的后继。 将last节点splay到root，这时last的左子树皆小于x 将next节点splay到last的子节右点，此时next的右子树皆大于x next的左节点rm必然满足 last &lt; rm &lt; next，删除rm即可 1234567891011121314void remove(int x) &#123; int last = pre(x), next = suc(x); splay(last); splay(next, last); int rm = node[next].ch[0]; if(node[rm].cnt &gt; 1) &#123; node[rm].cnt--; splay(rm); &#125; else &#123; node[next].ch[0] = 0; pushup(next); pushup(root); &#125;&#125; rank查找排名为k的节点 用一个指针cur从root开始查找，每次根据左子树大小于k的关系修改cur以及k。 12345678910111213int rank(int k) &#123; int cur = root; while(1) &#123; if(node[cur].ch[0] != 0 &amp;&amp; k &lt;= node[node[cur].ch[0]].size) &#123; cur = node[cur].ch[0]; &#125; else if(k &gt; node[node[cur].ch[0]].size + node[cur].cnt) &#123; k -= node[node[cur].ch[0]].size + node[cur].cnt; cur = node[cur].ch[1]; &#125; else &#123; return cur; &#125; &#125;&#125; 参考资料伸展树- 维基百科，自由的百科全书 Splay Tree Introduction","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://keepthethink.github.io/tags/数据结构/"}]},{"title":"一维数据结构学习笔记","date":"2019-03-15T02:15:08.000Z","path":"2019/03/15/一维数据结构学习笔记/","text":"一维数据结构学习笔记链表链表:按顺序记录元素的线性数据结构。 其中的“顺序”是逻辑上的顺序，不一定是物理存储上的顺序。 链表分为单向与双向两种： 1.单向链表:每个元素只记录了下一个元素的位置。 2.双向链表:每个元素记录了上一个及下一个元素的位置。 代码实现：123456789//用类来定义链表中的每个元素。class Node &#123;public: int v = 0; Node * next = NULL, * prev = NULL; /*前一个元素或者后一个元素可以不存在，所以必须要使用指针类型。*/ Node(int v = 0, Node * next = NULL, Node * prev = NULL):v(v), next(next), prev(prev) &#123;&#125;&#125;; 链表常用操作:构造链表通过实例化链表类，创建链表的每个元素并建立元素之间的关系。 代码实现：123456//构造一个只有头尾两个元素的链表。Node* head = new Node(); Node* tail = new Node(); head -&gt; next = tail;tile -&gt; prev = head; 链表常用操作:遍历链表将链表头赋值给临时变量，然后不断寻找下一个元素直到空。 代码实现：12345Node* i = head;while (i -&gt; next != NULL) &#123; i = i -&gt; next; //需要对链表元素进行的操作&#125; 链表常用操作:插入元素找到要插入元素的位置，一般是记录前一个元素。重新设置插入位置两边的元素和插入元素的关系。 代码实现：1234567//在元素p后面插入元素ii -&gt; next = p -&gt; next;i -&gt; prev = p;if (p -&gt; next != NULL) &#123; p -&gt; next -&gt; prev = i;&#125;p -&gt; next = i; 注意: 1.修改关系的顺序. 2.特判插入链表头的情况。 链表常用操作:删除元素首先，找到要删除的元素。 重新设置该元素的前后元素之间的关系，并根据需要释放元素。代码实现：1234567if (i -&gt; next != NULL) &#123; i -&gt; next -&gt; prev = i -&gt; prev;&#125;if (i -&gt; prev != NULL) &#123; i -&gt; prev -&gt; next = i -&gt; next;&#125;delete i; 注意: 如果有变量用来记录链表头，头被删除时要记得更新。 链表尾同理。 链表 Q&amp;AQ：单向链表可以进行删除元素操作吗? A：可以。通过预判下一个元素的方式，找到要删除元素的上一个元素，再更新下一个元素。123if (pr -&gt; next != NULL) &#123; pr -&gt; next = pr -&gt; next -&gt; next;&#125; 当然，还是要特判删除链表头的情况。 Q：还有别的方式可以用来实现链表吗? A：通常情况下，使用数组来实现链表会更加简便。 给每个元素一个编号(地址)，以代替指针的引用。 为了记录每个元素的属性，可以使用结构体、二维数组或者多个数组。 Q：用数组实现链表有哪些缺点? A：1.数组必须一次性初始化，并且长度固定。2.删除元素不会真正的释放空间。 队列从严格意义上来说，队列是一种特殊的链表，只支持添加队列尾元素和删除队列头元素两种操作。 或者说，队列是链表的子集。 队列常用操作:从队列尾部添加元素创建一个新元素，将队尾元素的下一个元素指向新元素。 将队尾移动到新元素。 代码实现：123Node* newTail = new Node();tail -&gt; next = newTail;tail = newTail; 队列常用操作:从队列头部删除元素记录队头元素。 将队头元素移动到它的下一个元素。根据需要释放旧的队头元素。 代码实现：123Node* oldHead = head;head = head -&gt; next;oldHead -&gt; next = NULL; 注意： 还要特判队列为空的情况。 数组:一种特殊的队列用两个整数表示数组的下标，作为队头和队尾的指针。 删除元素则将队头指针+1，添加元素则将队尾指针+1。 队头指针超过的队尾指针表示队列为空。 循环队列:循环重复利用被删除空间的数组队列移动指针后如果超出了数组长度，则重置为0。 当尾指针追赶上头指针时，表示队列溢出。 定义：123const int LENGTH = 100;Node* queue[LENGTH];int head = 0, tile = 0; 添加元素：123456789bool push(Node* t) &#123; if(head != (tail + 2)) &#123; // 判断满。 tail = (tail + 1) % LENGTH; queue[tail] = t; return true; &#125; else &#123; return false; &#125;&#125; 删除元素：123456789Node* pop() &#123; if (head != (tail + 1)) &#123; // 判断空。 Node* h = queue[head]; head = (head + 1) % LENGTH; return h; &#125; else &#123; return NULL; &#125;&#125; 队列 Q&amp;AQ：队列是单向链表还是双向链表? A：使用单向链表足以支持队列的操作。 Q：如果是双向队列，需要额外增加哪些操作? A：添加时要设置新元素的前一个元素，删除时要清空新队头的前一个元素。 Q：数组队列有哪些优点与缺点? A：优点：队列不需要删除中间元素，数组完全满足队列的操作要求。 缺点：删除掉的空间无法被重复利用。 Q：如何区分循环队列是满还是空? A：有两种方案： 1.用一个额外的变量记录队列的元素个数。 2.将实际队列的容量变为数组长度-1，让队列空和满时的队尾指针在不同的位置。 本文代码采用的是第二种方案 栈从严格意义上来说栈是一种特殊的链表，只支持添加栈尾元素和删除栈尾元素两种操作。 或者说，栈是链表的子集。 栈常用操作:从栈尾部添加元素1.创建一个新元素。2.将新元素的上一个元素指向栈尾元素。3.将栈尾移动到新元素。123Node* newTail = new Node();newTail -&gt; prev = tail;tail = newTail; 注意：还要特判栈为空的情况。 栈常用操作:从栈尾部删除元素1.记录栈尾元素。2.将栈尾元素移动到它的上一个元素。3.将旧栈尾元素的上一个元素置空。根据需要释放旧的栈尾元素。123Node* oldTail = tail;tail = tail -&gt; prev;oldTail -&gt; prev = NULL; 注意：还要特判栈为空的情况。 数组:一种特殊的栈用一个整数表示数组的下标，作为栈尾的指针。 添加元素则将栈尾指针+1，删除元素则将栈尾指针-1。 栈尾指针小于栈头元素的下标则表示栈为空。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://keepthethink.github.io/tags/数据结构/"}]},{"title":"洛谷题解P1119【灾后重建】","date":"2019-03-09T11:19:04.000Z","path":"2019/03/09/洛谷题解P1119【灾后重建】/","text":"本题基本上是Floyd的模版题，适合初学Floyd的OIer练习。 本题的重点在于并非在每一个时刻，每一个节点都可以到达，所以应枚举目前所有可以到达的节点k，并以k为中转点进行更新。 同时，因为出题人已经给数据排好了顺序，发现未建成时直接中断即可。 闲话少说，主要看代码注释。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt; #include&lt;algorithm&gt;using namespace std;const int MAXN = 200 + 5;const int INF = 1e9;int edge[MAXN][MAXN], times[MAXN];int n, m, q;/*init()函数：Floyd初始化*/void init() &#123; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; edge[i][j] = (i == j ? 0 : INF);//节点到自身的距离为0 &#125; &#125;&#125;/*addEdge()函数：在邻接矩阵中添加一条（双向）边*/void addEdge(int i, int j, int v) &#123; edge[i][j] = edge[j][i] = v;//双向边处理&#125;/*input()函数：输入数据*/void input() &#123; scanf(\"%d%d\", &amp;n, &amp;m); init(); //读入n, m后进行初始化 for(int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;times[i]); &#125; for(int i = 0; i &lt; m; i++) &#123; int x, y, v; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;v); addEdge(x, y, v); &#125;&#125;/*update()函数：以k为中转点更新最短路*/void update(int k) &#123; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; edge[i][j] = min(edge[i][j], edge[i][k] + edge[k][j]); &#125; &#125;&#125;void work() &#123; int cur = 0; scanf(\"%d\", &amp;q); for(int i = 0; i &lt; q; i++) &#123; int x, y, t; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;t); //这里是重点 while(times[cur] &lt;= t &amp;&amp; cur &lt; n) &#123; update(cur);//若当前可以经过村庄cur，以cur为中转点更新最短路径 cur++; &#125; if(times[x] &gt; t || times[y] &gt; t || edge[x][y] == INF) &#123; printf(\"-1\\n\");//村庄x尚未建成,村庄x尚未建成或村庄x与村庄y在t时并不连通 &#125; else &#123; printf(\"%d\\n\", edge[x][y]); &#125; &#125;&#125;int main() &#123; //简洁的main()函数 input(); work(); return 0;&#125;","tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://keepthethink.github.io/tags/洛谷/"}]},{"title":"NOIP2018游记","date":"2019-03-08T14:39:54.000Z","path":"2019/03/08/NOIP2018游记/","text":"出师（1） 起床看见洛谷首页上显示的“距NOIP2018还有-1天”时，差点把嘴里的一口早饭喷了出来。 不过又想一下，要是一大早看见个“距NOIP2019还有365天”，估计瞬间会感觉压力山大。。。 (2) 进考场前竟然下起了倾盆大雨，从地铁站出来后，举着伞转了一个小时才找到考场，期间不停的被地图坑。 （我才不会告诉你浪费这么多时间的真正原因是使用迭代加深搜索找考场。） 进了考场发现有惊喜。。。机房竟然有网！有网！结果在考试前网断了。。。然后开始调整编辑器，以至于没注意到别人都开始打代码了。。。 第一题，水题，鉴定完毕。分析：可能连模拟都算不上，直接从头到尾扫描一遍即可。 但虽说是水题，也有一些坑点： 读入要用 string + cin + getline()! 读入要用 string + cin + getline()! 读入要用 string + cin + getline()! 重要的事情说三遍！ @垃圾一个 就是在这一点上炸了。 判断时要自编函数或alnum，不能用ctype.h中的isprint()函数，要用isalnum()函数。 如果你问”isprint()函数是什么”或”isalnum()函数是什么”,请自行忽略这段话并自觉编写判断函数。 别问我为什么，Luogu自测只有20分。 代码：123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;bool check(char c) &#123; if('0' &lt;= c &amp;&amp; c &lt;= '9') &#123; return true; &#125; if('a' &lt;= c &amp;&amp; c &lt;= 'z') &#123; return true; &#125; if('A' &lt;= c &amp;&amp; c &lt;= 'Z') &#123; return true; &#125; return false;&#125;int main() &#123; string s; getline(cin, s); int len = s.length(); int ans = 0; for(int i = 0; i &lt; len; i++) &#123; if(check(s[i])) &#123; ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 第二题，暴力枚举，鉴定完毕。分析： 先计算好每一个军营的气势，同时累加双方的气势总和（输入后处理） 枚举每一个军营，检查若将工兵放在此位置是否可减少双方差距，并更新最小值与位置。 输出位置 写第一遍时大概思路就酱。 运行结果： 样例#1:Pass 样例#1:Pass 样例#3:Beng! 又看了一下数据范围，对于 100% 的数据，n ≤ 10 ^ 5,ci,s1,s2≤10^9。 10^9? “十年OI一场空，没开long long 见祖宗”，这话果然没错。 除int main()外的所有int皆换成long long，OK。 PS:如12345#define int long longsigned main() &#123; //some code return 0;&#125; 之类的旁门左道，为了安全起见，大家不要滥用哦QwQ。有本事你写个typedef int long long看报不报错 第三题。。。我这种小蒟蒻怎么可能作对前三题呢QwQ,又怎么可能想到DP正解QwQ 所以我挥手打了贪心。。。当我发现第三个样例没过时已经来不及了 先说说贪心具体思路： 将学生按照到达时间从小到大排个序 用一个光标变量记录目前接到了第几个学生，如果还有人没被接到，就继续循环知道所有人都被接到为止。 每次循环时检查当前这个人是否值得带，若值得则将光标后移。 每次循环后将时间加上开车所需要的时间。 最后累加总等待时间并输出。 答案正确率：玄学 到各大网站上测之，30分有之，80分有之，一切随缘。 第四题本蒟蒻骗了分，没脸来这胡说了。。。总结咳咳咳。。。 (1)考试策略的应用亏得我这只小蒟蒻还在进考场前看了1h AK NOI 的各位dalao 呕心沥血写的各种考场策略，结果一进考场简直就像接受了A级记忆删除，什么都忘得一干二净： 一，二题打完过了样例就去打第三题。（double-plus-scared） 第三题贪心死活过不了第三个点还执迷不悟认为就是贪心。 第四题明明有子任务放着不做打随机数。 (2)考场心态的调整众所周知，在NOIP考场这种地方要想保持心态稳定是不可能的。然而如果吓得完全写不出代码就凉凉了。总结就是一定要冷静冷静冷静再冷静，一定不要像某人一样，贪心错了都想不到半个动规。 最后，祝大家：123while(NOIP2019.rp &lt; NOIP2019.rp + 1) &#123; NOIP2019.rp++;&#125;","tags":[{"name":"NOIP","slug":"NOIP","permalink":"https://keepthethink.github.io/tags/NOIP/"}]}]