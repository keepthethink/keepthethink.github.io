---
title: 洛谷题解 P1002 【过河卒】
date: 2019-04-12 20:34:40
tags:
---

看到题目二话不说用了搜索，直到在提交前看了一下算法标签，又看了一下数据范围。。。

状态转移方程的推导并不复杂，每次判断卒是否能走到这个格子，不可以则为0（显而易见），可以则为下方与左方的值之和。

上代码，这道题算是一道DP入门题吧。

```cpp
#include<stdio.h>

const int MAXN = 20 + 5;
const int attack[9][2] = {{0, 0}, {1, 2}, {2, 1}, {-1, 2}, {2, -1}, {1, -2}, {-2, 1}, {-1, -2}, {-2, -1}};
long long dist[MAXN][MAXN];
int map[MAXN][MAXN];
int n, m, x, y;

void init(void) {
    for(int i = 0; i < 9; i++) {
        if(x + attack[i][0] <= n && x + attack[i][0] >= 0) {
            if(y + attack[i][1] <= m && y + attack[i][1] >= 0) {
                map[x + attack[i][0]][y + attack[i][1]] = true;
            }
        }
    }
}

int main() {
    scanf("%d%d%d%d", &n, &m, &x, &y);
    
    init();
    
    int k = 1;
    for(int i = 0; i <= n; i++) {
        dist[i][0] = map[i][0] ? k = 0 : k;
    }
    k = 1;
    for(int i = 0; i <= m; i++) {
        dist[0][i] = map[0][i] ? k = 0 : k;
    }
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++) {
            dist[i][j] = map[i][j] ? 0 : dist[i - 1][j] + dist[i][j - 1];
        }
    }
    
    printf("%lld\n", dist[n][m]);
    
    return 0;
}
```