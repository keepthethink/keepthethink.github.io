<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[洛谷题解P1119【灾后重建】]]></title>
    <url>%2F2019%2F03%2F09%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3P1119%E3%80%90%E7%81%BE%E5%90%8E%E9%87%8D%E5%BB%BA%E3%80%91%2F</url>
    <content type="text"><![CDATA[本题并不是Floyd的模版题，适合初学Floyd的OIer练习。 本题的重点在于并非在每一个时刻，每一个节点都可以到达，所以应枚举目前所有可以到达的节点k，并以k为中转点进行更新。 同时，因为出题人已经给数据排好了顺序，发现未建成时直接中断即可。 闲话少说，主要看代码注释。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt; #include&lt;algorithm&gt;using namespace std;const int MAXN = 200 + 5;const int INF = 1e9;int edge[MAXN][MAXN], times[MAXN];int n, m, q;/*init()函数：Floyd初始化*/void init() &#123; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; edge[i][j] = (i == j ? 0 : INF);//节点到自身的距离为0 &#125; &#125;&#125;/*addEdge()函数：在邻接矩阵中添加一条（双向）边*/void addEdge(int i, int j, int v) &#123; edge[i][j] = edge[j][i] = v;//双向边处理&#125;/*input()函数：输入数据*/void input() &#123; scanf("%d%d", &amp;n, &amp;m); init(); //读入n, m后进行初始化 for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;times[i]); &#125; for(int i = 0; i &lt; m; i++) &#123; int x, y, v; scanf("%d%d%d", &amp;x, &amp;y, &amp;v); addEdge(x, y, v); &#125;&#125;/*update()函数：以k为中转点更新最短路*/void update(int k) &#123; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; edge[i][j] = min(edge[i][j], edge[i][k] + edge[k][j]); &#125; &#125;&#125;void work() &#123; int cur = 0; scanf("%d", &amp;q); for(int i = 0; i &lt; q; i++) &#123; int x, y, t; scanf("%d%d%d", &amp;x, &amp;y, &amp;t); //这里是重点 while(times[cur] &lt;= t &amp;&amp; cur &lt; n) &#123; update(cur);//若当前可以经过村庄cur，以cur为中转点更新最短路径 cur++; &#125; if(times[x] &gt; t || times[y] &gt; t || edge[x][y] == INF) &#123; printf("-1\n");//村庄x尚未建成,村庄x尚未建成或村庄x与村庄y在t时并不连通 &#125; else &#123; printf("%d\n", edge[x][y]); &#125; &#125;&#125;int main() &#123; //简洁的main()函数 input(); work(); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2F2019%2F03%2F08%2FNOIP2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[出师（1） 起床看见洛谷首页上显示的“距NOIP2018还有-1天”时，差点把嘴里的一口早饭喷了出来。 不过又想一下，要是一大早看见个“距NOIP2019还有365天”，估计瞬间会感觉压力山大。。。 (2) 进考场前竟然下起了倾盆大雨，从地铁站出来后，举着伞转了一个小时才找到考场，期间不停的被地图坑。 （我才不会告诉你浪费这么多时间的真正原因是使用迭代加深搜索找考场。） 进了考场发现有惊喜。。。机房竟然有网！有网！结果在考试前网断了。。。然后开始调整编辑器，以至于没注意到别人都开始打代码了。。。 第一题，水题，鉴定完毕。分析：可能连模拟都算不上，直接从头到尾扫描一遍即可。 但虽说是水题，也有一些坑点： 读入要用 string + cin + getline()! 读入要用 string + cin + getline()! 读入要用 string + cin + getline()! 重要的事情说三遍！ @垃圾一个 就是在这一点上炸了。 判断时要自编函数或alnum，不能用ctype.h中的isprint()函数，要用isalnum()函数。 如果你问”isprint()函数是什么”或”isalnum()函数是什么”,请自行忽略这段话并自觉编写判断函数。 别问我为什么，Luogu自测只有20分。 代码：123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;bool check(char c) &#123; if('0' &lt;= c &amp;&amp; c &lt;= '9') &#123; return true; &#125; if('a' &lt;= c &amp;&amp; c &lt;= 'z') &#123; return true; &#125; if('A' &lt;= c &amp;&amp; c &lt;= 'Z') &#123; return true; &#125; return false;&#125;int main() &#123; string s; getline(cin, s); int len = s.length(); int ans = 0; for(int i = 0; i &lt; len; i++) &#123; if(check(s[i])) &#123; ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 第二题，暴力枚举，鉴定完毕。分析： 先计算好每一个军营的气势，同时累加双方的气势总和（输入后处理） 枚举每一个军营，检查若将工兵放在此位置是否可减少双方差距，并更新最小值与位置。 输出位置 写第一遍时大概思路就酱。 运行结果： 样例#1:Pass 样例#1:Pass 样例#3:Beng! 又看了一下数据范围，对于 100% 的数据，n ≤ 10 ^ 5,ci,s1,s2≤10^9。 10^9? “十年OI一场空，没开long long 见祖宗”，这话果然没错。 除int main()外的所有int皆换成long long，OK。 PS:如12345#define int long longsigned main() &#123; //some code return 0;&#125; 之类的旁门左道，为了安全起见，大家不要滥用哦QwQ。有本事你写个typedef int long long看报不报错 第三题。。。我这种小蒟蒻怎么可能作对前三题呢QwQ,又怎么可能想到DP正解QwQ 所以我挥手打了贪心。。。当我发现第三个样例没过时已经来不及了 先说说贪心具体思路： 将学生按照到达时间从小到大排个序 用一个光标变量记录目前接到了第几个学生，如果还有人没被接到，就继续循环知道所有人都被接到为止。 每次循环时检查当前这个人是否值得带，若值得则将光标后移。 每次循环后将时间加上开车所需要的时间。 最后累加总等待时间并输出。 答案正确率：玄学 到各大网站上测之，30分有之，80分有之，一切随缘。 第四题本蒟蒻骗了分，没脸来这胡说了。。。总结咳咳咳。。。 (1)考试策略的应用亏得我这只小蒟蒻还在进考场前看了1h AK NOI 的各位dalao 呕心沥血写的各种考场策略，结果一进考场简直就像接受了A级记忆删除，什么都忘得一干二净： 一，二题打完过了样例就去打第三题。（后来自测竟然对了，double-plus-scared） 第三题贪心死活过不了第三个点还执迷不悟认为就是贪心。 第四题明明有子任务放着不做打随机数。 (2)考场心态的调整众所周知，在NOIP考场这种地方要想保持心态稳定是不可能的。然而如果吓得完全写不出代码就凉凉了。总结就是一定要冷静冷静冷静再冷静，一定不要想我一样，贪心错了都想不到半个动规。 最后，祝大家：123while(NOIP2019.rp &lt; NOIP2019.rp + 1) &#123; NOIP2019.rp++;&#125;]]></content>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
