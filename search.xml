<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>题解 SP196 【MUSKET - Musketeers】</title>
      <link href="/archives/1389482586/"/>
      <url>/archives/1389482586/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在模拟赛中遇到了这道题。（后来才知道是SPOJ上的原题）</p><p>话不多说，开始动态规划三步走。$Let’s\ go!$</p><h2 id="定义状态"><a href="#定义状态" class="headerlink" title="定义状态"></a>定义状态</h2><p>假设第1个人能够赢得整场决斗：</p><p>倘若把这位仁兄复制一份，放在$n + 1$的；那么，在一阵厮杀后，他和自己的分身应当能够相遇。那么，我们就和 在<a href="https://www.luogu.org/problem/P1880" target="_blank" rel="noopener">[NOI1995]石子合并</a>中一样，将数组翻倍后再处理。</p><p><del>显而易见</del>定义状态如下：</p><p>$dp_{i,j}$为第$i$人与第$j$人是否能够相遇</p><h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><p>现在思考一下：第$i$人与第$j$人是否能够相遇？</p><p>按照区间DP的思维，我们在$i$与$j$之间选取一个人$k$</p><p>若$i$与$k$能相遇，$k$与$j$能相遇，且$i$与$j$当中的任何一个人能干掉$k$</p><p>故状态转移方程为：</p><p>$$dp_{i,j} = dp_{i,k} \&amp;\&amp;\ dp_{k,j} \&amp;\&amp;\ (w_{i,k} || w_{j,k})$$</p><h2 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h2><p><del>显然，</del> 若两人本来就相邻，则$dp_{i,j} = 1$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> * <span class="number">2</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w[MAXN][MAXN], f[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)); <span class="comment">//数组清零，我在这里掉了两次坑</span></span><br><span class="line">        <span class="built_in">memset</span>(w, <span class="number">0</span>, <span class="keyword">sizeof</span>(w));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">                w[i][j] = c - <span class="string">'0'</span>;</span><br><span class="line">                w[i + n][j + n] = w[i + n][j] = w[i][j + n] = w[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n + <span class="number">1</span>; l++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + l - <span class="number">1</span> &lt;= n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + l - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(l &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    f[i][j] = <span class="number">1</span>; <span class="comment">//边界条件</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(f[i][k] &amp;&amp; f[k][j] &amp;&amp; (w[i][k] || w[j][k])) &#123;</span><br><span class="line">                        f[i][j] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i][i + n]) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i][i + n]) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> SPOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>慢慢的，就没有了，就像从未存在过</title>
      <link href="/archives/3811762271/"/>
      <url>/archives/3811762271/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><center><br><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="510" height="86" src="//music.163.com/outchain/player?type=2&id=511333096&auto=0&height=66"></iframe><br></center><p>几年以前，我曾经嘲笑过某科技界大佬。当时他说：也许90后、95后会慢慢不知道谷歌是什么网站。</p><p>　　那一年，这对于我来说简直就是世界上最好笑的笑话。谷歌，全世界最卓越的互联网公司，活在互联网的一代中国人，会不知道他们的网站？</p><p>　　今天，我收回这句嘲笑。因为这件不可能的事，它慢慢变成了现实。</p><p>　　没有人再关注什么谷歌不谷歌。对他们来说，百度也蛮好用的，反正他们几乎没用过谷歌。没有谷歌又怎样？大家还是开心的刷微博，看微信，听歌，看娱乐节目。对于从来就不知道谷歌的人来说，少了谷歌又有什么影响？</p><p><img src="https://keepthethink.github.io/images/no.jpg" alt="慢慢的，就没有了，就像从未存在过"></p><p>　　多年前，我们也是可以登陆Facebook的。其实这个网站和校内一样，也挺蠢的。可在上面你能看到老外们的生活，可以轻易的跟一万公里以外的人互相拜访，可以看到很多根本不会开到校内上的主页。你用汉语回复，下面给你聊起来的可能是香港仔，可能是台湾人。你用英语回复，说不定有比你英语用的更蹩脚的寂寞的北欧人来跟你搭讪。你感觉地球真的变成了地球村，你还没拉门走出去，别人就推门走了进来。</p><p>　　然后，它就没有了。起初，它的失踪激起了很大的声音，后来，声音就消失了。</p><p>　　多年前，我们也是可以登陆Twitter的。其实这个网站和微博一样，也不过是些信息流，刷上一整天，也不见得有什么用处。但至少，你可以以最快速度获取你想知道的任何新事，你会真正了解什么事情在全世界是流行的，而不是经过各种截图、翻译、转发，甚至曲解、断章取义、黑白颠倒的东西。你知道的是真相，赤裸裸的，也许有点太短的真相。但至少中间不会有无数人的加工与再加工，偏激、片面，就在这个过程中产生了，不管后来者有意还是无意。</p><p>　　然后，它就没有了。首先是它的本体没有了，然后它的模仿者也没有了，模仿者的模仿者也没有了。只剩一个模仿者的模仿者的模仿者，现在你每天能在上面看到无数广告。</p><p>　　多年前，我们也是可以登陆YouTube的。对于有的人来说，这个网站就是个大型优酷，当年有人信誓旦旦的说，没有YouTube，我们中国人会很快让优酷超过YouTube。可这么多年过去了，视频还是那么卡，内容还是那么垃圾，原创还是那么容易被盗窃，视频丰富度还是那么的可怜。在YouTube上，你能看到全世界最棒的手艺人，最逗乐的笑话，最天马行空的创意，最激荡人心的音乐，最美好的完美瞬间，可在优酷上，你想看一分钟视频，请先看半分钟广告。</p><p>　　哦，对了。Instagram，有些人可能感觉它和QQ空间也差不多。可我在上面关注了六百多个摄影师，它们都是顶好顶好的影像记录者，每天看他们的作品，我感觉到很幸福，那种即使没有到那里去，也身临其境的幸福。我还在上面认识了一个日本的爱自拍的帅小伙，一个爱喝酒的韩国大叔，一个十年前到过中国今天会在每张我发的紫禁城照片下点赞的美国大爷，一个美丽无比的俄罗斯妹子，我和他们基本上都难以交流，语言是很大的障碍，但几个简单的单词，心意也就到了，这种感觉，有时候比多年老友相聚还兴奋。因为这是人类不同族群自由交流互相沟通的过程，这种过程很神奇，真的很神奇。</p><p>　　可现在，它没有了，它之所以没有就因为在某个特定的时间你在搜索特定的词汇时，会搜出来特定的照片。虽然这么搜的人并不多，虽然看到的人也不会大惊小怪，也不会觉得天黑了，天亮了，天要塌了，天要变了。可它就是没了，Instagram，就这么没了。谷歌也是这么没的，Twitter也是这么没的，Facebook也是这么没的。不知道是什么人，在什么场合，说了什么话，下了什么决定。就要有超过十亿人像陷于哥谭市的孤岛里一样，看着一座又一座桥梁被炸掉，又被炸掉，又被炸掉，然后，就什么都没了。</p><p>　　我时常觉得悲哀，真的好悲哀，一个我根本不认识也不知道是谁的人，也许是一个群体，在不断抢走我身边的东西，而我却无能为力。我抱怨一声，他听不到，任何人都听不到。我怒吼一句，身边的大多数人却像看疯子一样的看着我。我哀嚎一声，这声音被阻碍在黑黑的幕墙以里。我发出尖锐的嘶吼，这声音传不了多远，就和我那被抢走的东西一样，消失了，不见了，就像从来没存在过一样。</p><p>　　对于本来就没存在过的东西，有谁又会觉得在意呢？那些本来拥有又被掠夺的人的哀愁，后来的人又怎么懂呢？我曾经是拥有一切的，我曾经是拥有世界的，我站在这片土地上，呼吸的是自由的空气，饮下的是自由的琼浆玉液。就在长的无法计数的时间里，我自由生命的一部分又一部分就这么被杀死了，突然就杀死了。可我还始终觉得，它们还奄奄一息的活着，就像它们是慢慢的死去的一样。</p><p>　　可它们终归是死了，而且随着它们的死，愈来愈多的事情慢慢的发生了，很慢很慢，几乎不被人察觉，可还是发生了。</p><p>　　没有谷歌，我可以用百度呀。可某些结果被越挪越后，越挪越后，最后就不见了。就像本来就不该搜出这个结果一样。</p><p>　　没有Facebook，我可以用校内呀。可你想发只有在Facebook上能发的文章，很快在校内上就失踪了。接着，校内变成了人人，话题变成了人人都关心的话题。大家都在抢着看星座、明星、八卦、娱乐。没有人会关心什么消失了，反正它们本来也没多少存在感。</p><p>　　没有YouTube，我可以用优酷呀。可你却经常只能在优酷上看到抄袭别人的作品，而且还不署名，而且还洋洋得意，而且还自我陶醉，就好像那个idea本来属于他自己一样。你看了还要惊呼，他是如此的有创意！好一个抄袭的创意，可你却不知道，因为你不知道这个世界上有个网站叫YouTube。</p><p>　　没有Twitter，我还可以用微博呀。可你想知道最近发生了什么，你搜的越勤快，越能看到越明显的“根据相关法律法规，相关搜索结果不予显示”。时间长了，你想，反正知道了也没什么用，不如不看了。</p><p>　　慢慢的，一扇又一扇的门关上了。今天你打开世界上最大的博客网站，发现它没了。明天你一看，世界上最好的设计师分享网站没了，一开始是刷新的很慢很慢，后来它就没了。过两天再一看，平常每天都会读两篇文章的媒体网站没了，那里的文章缤纷多彩，最后都变成了该页无法显示几个字。再过几个月，大学的网站不让上了，摄影师的网站不让上了，就连百度日本这种自家网站，也没了。</p><p>　　接着，漫画看不了了，接着，动画看不成了。接着，美剧英剧失踪了。下载美剧英剧的网站又又又失踪了。尊重正版，保护权益，行吧，然后字幕网站也没了。</p><p>　　游戏没了，你习惯性登陆的游戏网站，发现下载栏正在整治中。论坛关了，天天都在看的论坛，突然接到相关部门的电话，因为“报备问题”不让办了。个人网站，私人博客，对不起，说没就没有，你在上面存了多少多年辛勤耕耘的东西都没用。</p><p>　　你关注的人，有一天你登陆微博，发现他怎么好久都没说话了，然后你搜索了一下，发现他的账号不存在了，而且你搜他的名字，他的名字未予显示。</p><p>　　一盏一盏的灯，灭了。四面八方的光源，消失了。我们生活的五光十色的世界，变成了一片黑色。</p><p>　　天黑了，那么睡觉吧，但愿长醉不复醒。</p><p>　　最后，我们变成了一群做梦的人，这个梦的名字，叫根据相关法律法规，相关搜索结果不予显示梦。</p><p>　　作者：小海，来源：豆瓣网，<a href="http://www.douban.com/note/456932116/" target="_blank" rel="noopener">原文</a>已被和谐</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OIer&#39;s News 【创刊期】</title>
      <link href="/archives/3790557036/"/>
      <url>/archives/3790557036/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="创刊期"><a href="#创刊期" class="headerlink" title="创刊期"></a>创刊期</h2><h3 id="创刊期-1"><a href="#创刊期-1" class="headerlink" title="创刊期"></a>创刊期</h3><p>大家坚定一个信念吧:</p><p><img src="https://i.loli.net/2019/03/16/5c8c92d2107f5.png" alt></p><h2 id="我们是OIER"><a href="#我们是OIER" class="headerlink" title="我们是OIER"></a>我们是OIER</h2><h3 id="我们是O——I——E——R！"><a href="#我们是O——I——E——R！" class="headerlink" title="我们是O——I——E——R！"></a>我们是O——I——E——R！</h3><p>我们是OIer， 所以我们 不用在跑道上挥汗如雨； 不用在球场上健步如飞； 更不用在没事的时候， 经受非人的体能训练……</p><p>但是， 我们却要把头脑 高速运转， 还要接受一大堆 大学生也只是 “了解即可”的知识， 把一个个抽象的问题 转化为一篇篇 优美的代码， 才能在F9按下以后 获得欢呼。</p><p>不要以为我们 机房里没有风吹， 没有日晒， 就比勤劳的体育生们轻松， 只不过是大脑和四肢 的区别罢了。</p><p>可是， OIer的寂寞和委屈又有谁能懂？ 自习课鏖战机房， 却被认为而是逃课上网； 为荣耀耽误考试去比赛， 却被认为是逃避。 体育的同学们虽然辛苦， 但在挥汗如雨的背后， 有人在喝彩鼓掌； 在风吹日晒的同时， 有粉丝在仰慕。</p><p>而我们呢？ 与UnAC较劲的时候， 只有那一遍遍的运行窗口， 知道我们的不屈； 刷题的漫漫长夜， 只有陪伴我们的笔记本电脑， 知道我们的不懈； 在自习课别人学习的时候， 只有板砖般的算法导论， 知道我们的进取； 在机房泡得抢不上饭的时候， 只有五毛一包的干脆面， 知道我们的执着……</p><p>没有人会理解， OIer见面， 除了程序、算法之外 别无他言。 我们的世界里， 从来不会有游戏、歌星的出现。 这不是被家长逼迫的“小三门”， 是我们的兴趣， 我们的爱好， 乃至我们的事业。</p><p>每一个OIer都幻想着 自己脖子上可以 挂上一块沉甸甸的金牌， 而不是 万恶的应试教育的枷锁。 没准哪个OIer， 就是下一个艾伦•图灵， 挑战头脑的极限， 去做最不平凡的自己。。。。。。。</p><h4 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h4><p><img src="https://i.loli.net/2019/03/23/5c95ec9f01e9f.png" alt="版权.PNG"></p><h3 id="一天"><a href="#一天" class="headerlink" title="一天"></a>一天</h3><p>一天,我听我同学说:</p><p>“有一群人,<del>她</del>们天天不分昼夜的从床上爬起来,说什么“0点打卡祭”什么鬼的。</p><p>每天坐在电脑前敲着一些奇奇怪怪的看不懂的鬼东西。</p><p>然后为了一个看不懂的绿色框框和一个$\color{green}AC$不分昼夜的坐在电脑前。</p><p>还有,天天坐在电脑前不开一个游戏!</p><p>开什么叫做LuoGu啊,CSDN啦,博客园什么的鬼网页。</p><p>以及……</p><p>真搞不懂！”</p><p>我笑了,这不就是我吗?</p><p>我转身归去。</p><p>他叫道:“喂！别跑！”</p><p>我没有停,只静静地留下一句:“有朝一日,你也会像他们一样,而我,已经是了……”</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>写代码的小女孩</title>
      <link href="/archives/1301002429/"/>
      <url>/archives/1301002429/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>　　天冷极了，下着雪，又快黑了。这是NOIP的前夜。在这又冷又黑的晚上，一个衣衫破烂的小女孩在机房敲着代码。她从班里逃出来的时候还拿着一本算导，但是有什么用呢？那是一本很破旧的书——那么大，一向是她妈妈垫桌角的。她默写SPFA的时候，年级主任突然冲进机房，吓得她把算导都丢掉了。书叫一个学数竞捡起来拿着跑了。他说，他可以用那本书当草纸，证明切比雪夫定理。</p><p>　　小女孩只好自己写二叉堆，一双小脚冻得红一块青一块的。她面前的草纸堆得满满的，上面全是DP转移方程。这一整天，没有一个OJ让她AC一道题，她已经交了32遍采药了。</p><p>　　可怜的小女孩！她又冷又饿，浑身战栗地写着二叉堆。CRT显示器发出的光落在她的枯黄的长头发上，那干枯的头发打成卷儿披在肩上，看上去就像二叉树，不过她没注意这些。每个显示器里都透出光来，机房里飘着一股CPU发糊的怪味，因为这是NOIP前夜——她可忘不了这个。 </p><p>　　她在主函数前面停了下来，蜷着趴在键盘上。她觉得更冷了。她不敢回家，因为她还没调完二叉堆，没写对一个DP方程，教练一定会骂她的。再说，换成别的数据结构，一样写不出来。这些题都太水，虽然神犇都写过题解了，但是题解上一般都只有三个字：傻X题。</p><p>　　她几乎绝望了。啊，哪怕一个函数不会RE，对她也是有好处的！她每写一遍程序，跑出来的结果就不一样，要是她有数据，她就知道哪一个程序是算对了的。她得不到数据了，因为机房上不去网了，全校的网速都让隔壁的年级主任拿来下小电影了。如果能保证下一个程序能AC，她就敢再写几十KB的代码，但是她是不敢啊，她怕又算出来一个奇葩的结果来。 　　她新建了一个cpp重写了程序。编译通过了了，样例过了。这次，她感觉自己站在IOI的考场中AK。学校的大门上，贴着“我校学生以国际金牌向110周年校庆献礼”的条幅。在班级内的非诚勿扰中，全班男生都给她留了灯。这时候，程序又RE了，她面前只有cmd上的黑底白字。</p><p>　　她又写了一道模拟。这一回，她坐在美丽的二叉堆下。这棵二叉堆，比她在丽洁代码中看到的常数还要小，还要短。眼前是许多优美动人的ASCII码，那些都是她写的程序，各种可爱的指针在跳跃着，满世界都是系统栈，都在向她眨眼睛。小女孩向眼前的系统栈伸出手去。这时候，眼前的ASCII码还在，条幅还在，指针还在，年级主任还是和蔼地微笑着。只见那些代码那些指针越升越高越升越高，最后成了在天空中闪烁的星星。有一颗星星落下来了，在天空中划出了一道细长的红光。</p><p>　　 “有一个什么人快要死了。”小女孩说。唯一疼她的学姐保送之前告诉过她：一颗星星落下来，就有一个灵魂要到上帝那儿去了。</p><p>　　她notepad++中又写了一个快排。这一回，她把能用的IDE都用了。学姐出现在亮光里，是那么温和，那么快乐。 “学姐！”小女孩叫起来，“啊！请把我带走吧！我知道，系统栈一溢出，您就会不见的，像那校门的条幅，浮点数的精度，循环队列的空间一个样，就会不见的！”</p><p>　　她赶紧编译了5KB的高精度模板，要把学姐留住。一大把程序发出强烈的光，把机房照得跟白天一样明亮。学姐从来没有像现在这样温柔，这样美丽。她把小女孩抱起来，搂在怀里。她们俩在光明和快乐中飞走了，越飞越高，飞到那没有DP，没有图论，也没有数据结构的地方去了。</p><p>　　第二天清晨，这个小女孩坐在机房里，两腮通红，嘴上带着微笑。她死了，在NOIP的前夜死了。NOIP Day1的太阳升起来了，照在她小小的尸体上。小女孩坐在那儿，显示器上还有一坨编译过的代码。</p><p>　　“她想好好复习复赛。”人们说。谁也不知道她曾经看到过多么美丽的东西，她曾经多么幸福，跟着她学姐一起走向新世界的幸福中去。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>摘录自「SCP基金会」中的一些句子</title>
      <link href="/archives/2032683215/"/>
      <url>/archives/2032683215/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>已死之人，向赴死者致敬。</p><p>我想要宪法赋予我的那个世界。</p><p>大概你的确是死了，但我们还在前行，消逝的能够被盖棺定论，而还存在着的仿徨呐喊抗争着，却在眨眼就会丧命，空中会窜出无敌吃人大蜥蜴，永远有儿童和女孩在惨叫的世界的黄昏里，拾起那一朵清晨看见过的花。</p><p>当你们的时代过去，请继续送出信息，好让下一个声音响起来对抗黑暗。</p><p>他们很快乐，至少在最后之前。不是所有的船都得在黑夜中航行。</p><p>你已经做完了你必须去做的事，现在，请休息吧，晚安。</p><p>我会使得我们的宇宙成为一个值得拯救的宇宙的。</p><p>她死在一个遥远的地方，脸上带着笑容，手里握着武器，身边围着敌人。她向我们展示了一个真正的战士应该是什么样子。</p><p>我看到一片广阔的海岸，在我们面前展现的事物超越头脑所能理解的范畴，沙滩上的每一粒沙子，每一滴水和空气分子都是在讲述一个故事。每个都是要被唱响的歌。他们每个人都充满生机，笑声，苦难和仇恨。他们都是一样的，即使他们都是不同的。</p><p>我爱你，红。我爱你，安娜。五年，十一个月，二十天。</p><p>那些受影响的人，是因为他们失去了他们内心世界的孩子。他们不能只看到最表面的东西，他们把自己的观点注入一切然后从中获取乐趣。</p><p>神破碎自己，我们才得完整.</p><p>所以我央求你：这—真知—绝不能被抹去、遗忘。这不是收容。这是疯狂。</p><p>大概人们能哀叹于你的不幸，但没人有资格评论你为”不争”。在这个遍布异常的世界里，努力在绝大多数人眼前拉上一张布帘。从无数扭曲而血腥的异常下保护绝大多数人类的我们，可能面对着每天都有值得尊敬的人因异常而死亡的不幸，但也能在和这一切抗争着的同时，期冀着一个立于晨间，蝴蝶环绕翩翩飞舞的世界。</p><p>他想起内布拉斯加的麦田。</p><p>用伤害无辜者来掩盖自己的错误是心虚的体现，也永远掩盖不了。</p><p>他们也一样。</p><p>根据完整版资料我发现，601被姜特工发现的地方，就在那段时期执行流产手术频率最高的医院原址，更精确一点说，就在那个医院的化粪池原址。那一百天内被强制流产或者“生下来就掐死”的数以万计的婴儿，他们本可能成为你，可能成为我，可能成为这个世界上的任何一个人和任何一个人的爱人，但他们的生命还没开始，就被埋葬在了那个化粪池。</p><p>……是神又怎么样呢。这个国家最早的传说里并没有神的席位，取而代之的是被山挡住就决定挖山的农夫，被海淹死就去填海的小女孩，被太阳炙烤便搭箭指向太阳的猎人，或者从神那里偷来土壤治水的老人。“王侯将相，宁有种乎”，没错吧？我们的历史，从来不是由神兽或妖，而是由普通人来书写的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「文章转载」时代的悲哀</title>
      <link href="/archives/2640828482/"/>
      <url>/archives/2640828482/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>周六晚，影响中国2018年度物颁奖典礼在国宾馆举行。杨超越获“影响中国年度演艺人物”奖项，人们不禁感慨：</p><p>真是一个敢给，一个敢接，杨超越怎么影响中国了？</p><p>在微博热评中，有这样一句评论发人深省：“从这个人身上看到只要长得好看，就可以不劳而获。”</p><p>“影响中国”这四个字何其之重？</p><p>明星被捧上神坛，袁隆平却遭到辱骂，又是何等的悲哀？</p><p>“去年的今天超越还在村里，一年后的今天在钓鱼台国宾馆，什么小说也不敢这么写，魔幻现实主义。”</p><p>2018年对于杨超越是咸鱼翻身的一年。</p><p>一位从选秀节目《创造101》走红的选手，哭了整整一个夏天后，“蜕变”为国民锦鲤。</p><p>她在整个赛程中，几乎毫无进步，跳舞技能为零。</p><p>关键时刻只会哭，靠着傻白甜的人设收割大批粉丝，真正诠释了“爱哭的女孩运气不会太差。”</p><p>有人怒喊：“杨超越，你欠我10公升的公平和正义！”</p><p>从那之后，“杨超越”这三个字化身为锦鲤的存在，大量的粉丝应运而生。</p><p>“转发这个杨超越，不努力交白卷也能考第一名。” “转发杨超越，睡到心上人。”</p><p>王思聪在微博上说：“杨超越的出道是侮辱了其它十个人，侮辱了她们的努力、她们的汗水，她们的业务能力。”</p><p>可怕的不是锦鲤，而是转发锦鲤的人，真的相信杨超越的“成功”是一种偶然。</p><p>这个奖项不免让人想起今年5月份崔永元发的一个微博：一个真敢发，一个真敢领。</p><p>这条微博所指的正是范冰冰在今年获得了“国家精神造就者荣誉奖”事件。</p><p>相信大家心里都有共同的疑惑：她是如何代表国家精神的？</p><p>后来，范冰冰缴纳了8.84亿的巨额罚款。</p><p>群众们纷纷表示：贫穷限制了我的想象力。</p><p>彼时一位老兵感概地说到:</p><p>“8.84亿，是一名40岁的中国军人奋斗7998年的收入;8.84亿，足够列装一架歼20;8.84亿，能使中国多少贫困人口达到小康啊!”</p><p>字里行间，无不透露出这位八旬老人内心的苦楚与无奈。</p><p>2016年8月16日凌晨1点40分，由中国科学家自主研制的世界首颗量子科学实验卫星“墨子号”在酒泉卫星发射中心成功发射。</p><p>当英国等众多国家为之警惕、拍案叫绝时，我国人民却在“一心一意”关注王宝强与马蓉的离婚事件。</p><p>当屠呦呦获得诺贝尔奖时，黄晓明与Angelababy的婚礼热度已经让微博系统瘫痪。</p><p>后半段：之前网上晒出的当红演员的片酬表，Angelababy片酬8000万，鹿晗的报价竟高达1个亿！</p><p>演着最烂的戏，拿着巨额片酬，享受前呼后拥的待遇。</p><p>当这些数字赤裸裸的出现时，我们一次次地感受到了痛彻心扉的悲凉。</p><p>我们不是没有英雄可以敬重，我们不是没有功臣可以仰慕。</p><p>但我们的生活，却为何在不知不觉中，被流量明星给占满了？</p><p>前段时间，“杂交水稻之父“袁隆平上了热搜，不是被感恩，而是被辱骂。</p><p>有的人一转身，已为社会奉献半生心血。</p><p>晚年时，却等来一番莫须有的羞辱。</p><p>而所有的起因只是：袁隆平买了两部华为手机，摸了一下豪车，拥有一套别墅。</p><p>只因这些，网上就有人咒他暴毙。</p><p>“你是一个科学家，你怎么能那么有钱买两个华为手机？你怎么可以住豪宅？你怎么能摸豪车？“</p><p>他们只看到了他摸豪车，却不知道他现在开的只是一辆不到十万元的国产代步车，只因年龄大了，无法再骑电动车。</p><p>他们只看到了他拥有一栋豪宅，却不知道这是国家奖励给他的，辛苦了一辈子这是他应得的。</p><p>这栋豪宅如今已被他改造为研究水稻的科研室。袁隆平就在这栋豪宅里，日夜劳作，成功孕育出了海水种植耐盐碱水稻。</p><p>只靠这一项成果，我国一年可以增产粮食500亿公斤，可以多养活2亿中国人。</p><p>而这吃着粮食的人，却正在骂他晚年不保。</p><p>就在今年11月18日，第三届未来科学大奖颁奖典礼在北京举行，袁隆平获得未来科学大奖——生命科学奖的消息，早已淹没在各种明星八卦的热搜里。</p><p>没有人再去关注当年那个为了让中国人吃饱肚子，而倾尽一生的袁隆平。</p><p>他们更不知道，在今年的未来科学大奖典礼上，袁隆平老先生，倾诉了自己的两个梦想。</p><p>他眼里含着热泪说：</p><p>“我有两个梦，一个是禾下乘凉梦；还有一个梦，就是杂交水稻走向世界，覆盖全球梦。让杂交水稻能造福世界人民，为保障世界粮食安全发挥重大作用。”</p><p>每一句，都深深刺痛了大家的心。</p><p>当有些人舒舒服服坐在空调房里，为抖音主播刷礼物时。这位88岁的老人，仍然拖着年老的身体，在炎炎夏日蹒跚踱步，到了田地里。中暑是常有的事，他会随身带着药片防止晕倒。</p><p>袁隆平说：“我毕生的追求，就是让所有人都远离饥饿。”</p><p>2016年《面对面》采访袁隆平，他用近乎哽咽的声音说：</p><p>“我86岁了，身体不好了。”</p><p>早在几年前，老先生就被查出患有慢阻肺。这种病的治愈率非常低，目前能被治愈的患者只有不到30%。</p><p>他的家人都担心他的身体，劝他退休，不要再下田了。</p><p>可袁隆平老先生却始终坚持：</p><p>“我要在90岁前能够实现杂交水稻大面积示范亩产1200公斤，向党的100岁生日献礼，这是我的一个愿望。”</p><p>一字一句，满是真心。</p><p>老先生很少在媒体上露面，只因为：太浪费时间了，他的大量时间都是在稻田里，拖着年迈的身体，顶着烈日劳作。</p><p>他平时穿的衣服，简单素朴，没有名牌，一件衣服只花几十块钱。</p><p>在许多吃饱了肚子的农民眼里，袁隆平是“米菩萨”，是“神农下凡”。</p><p>当他听到这番盛赞时，急忙说到：“不敢当，实在不敢当啊。</p><p>菩萨在老百姓心中是能救苦救难的，我又何德何能，我就是个种了一辈子稻子的农民而已。”</p><p>明星出轨了，有人站出来这有什么大不了的，一个巴掌拍不响；明星家暴了，有人分分钟站出来为他澄清；明星吸毒了，有人立马说他只是一时糊涂，原谅他吧。</p><p>而如今，袁隆平老先生只是买了两个华为手机，就被诅咒暴毙。</p><p>在他们的眼里，作为一个科学家，你必须穷！</p><p>他们战战兢兢了一辈子，到头来却不允许他们过上好的生活。</p><p>这不禁让人想起那些坚持原创的独立音乐人，当他们过上好的生活后，人们会质疑他变了，撂下一句：“你作为一个独立音乐人，让你穷着挺好的。”</p><p>迟暮英雄被辱骂诅咒，流量明星拿着高价片酬，扪心自问一下，我们真的问心无愧吗？</p><p>现如今孩子们的梦想不再是当科学家，老师，工程师……而是整容当网红，做主播，参加选秀节目当明星。</p><p>宋丹丹曾在全国政协十二届第五次会议发出了这样的感慨：“那么多年轻人都想做网红，我很担忧。“</p><p>当下的网红门槛极低，没有学历要求，只要你拥有一张好看的脸蛋，敢于上镜头，世界就是你的。</p><p>网络上的主播坐在几平米的房间里，浓妆艳抹，打上灯光，和屏幕那头的粉丝们聊聊天、唱唱歌、讲讲笑话就可以收入几千甚至几万块。</p><p>越来越多的年轻人不再追求理想，也早已忘记初心。认为只要长得好看，就可以当饭吃。</p><p>十月份，一名叫“莉哥”的网红女主播因涉嫌在直播过程中，有辱国歌尊严，引发网民反感。</p><p>前段时间，有一名叫“蛇哥”的男主播为了吸人眼球，在自己妻子生产时，竟然打开了手机，在生产当天开启了直播！让大家看着他老婆生孩子！足足有50万人来围观！</p><p>蛇哥的妻子躺在产房里很害怕，他边直播边安慰说：“别怕，有这么多人陪着你。”</p><p>然而，就在蛇哥和看直播的粉丝互相竞猜孩子是男孩还是女孩时，直播间被虎牙官方直接封禁。</p><p>类似的事情数不胜数，让人不禁感慨到：是什么让这些人肆无忌惮？<br>其实人们担忧的不是网红本身，而是当下越来越多的年轻人的价值观发生了扭曲，认为读书无用，只要长得好看就可以赢得掌声和鲜花。</p><p>鲁迅说：“我们自古以来，就有埋头苦干的人，有拼命硬干的人，有为民请命的人，有舍身求法的人……</p><p>虽是等于为帝王将相作家谱的所谓‘正史’，也往往掩不住他们的光耀，这就是中国的脊梁。”</p><p>今日，我们虽不缺乏鲁迅口中的苦干、硬干、实干家，也不缺为民请命的理想者，但却缺少了一份敬重，缺少了一份理性。</p><p>今日，我们虽然需要蓬勃发展的文化生活，需要技艺精湛、德才兼备的好艺术家，但却真的不需要那些流量明星和低俗文化霸占热搜榜。</p><p>在追求流量的时代，人们渐渐地失掉初心与本真，不再思考生命与自我的意义，而是追求虚无的浮华。</p><p>狄更斯说：“这是一个最好的时代，这是一个最坏的时代。</p><p>人们面前应有尽有，人们面前一无所有。”</p><p>时代的好坏，取决于我们每一个人，究竟是选择沉沦，还是选择思考。</p><p>希望我们身边，能少一些端起碗来吃饭、放下筷子骂人的喷子，能多一些像袁隆平这样的实干家！</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 网络 </tag>
            
            <tag> 社会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五年计划</title>
      <link href="/archives/1579271507/"/>
      <url>/archives/1579271507/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>搜索</p><ul><li><p>填涂颜色</p></li><li><p>自然数的拆分问题</p></li><li><p>单词方阵</p></li><li><p>奇怪的电梯</p></li><li><p>字串变换</p></li><li><p>奶牛导航</p></li><li><p>夜空繁星</p></li><li><p>虫食算</p></li></ul><p>二分：</p><ul><li><p>砍树</p></li><li><p>奶牛晒衣服</p></li><li><p>丢瓶盖</p></li><li><p>营救</p></li><li><p>刺杀大使</p></li><li><p>花盆</p></li><li><p>借教室</p></li></ul><p>最短路：</p><ul><li><p>最小花费</p></li><li><p>牛大赛</p></li><li><p>灾后重建</p></li><li><p>邮递员送信</p></li><li><p>逃离僵尸岛</p></li><li><p>社交网络</p></li><li><p>电话线-1948</p></li><li><p>最长距离</p></li></ul><p>并查集/最小生成树：</p><p>（待补充）</p>]]></content>
      
      
      <categories>
          
          <category> 计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>洛谷题解 P1226 【【模板】快速幂||取余运算】</title>
      <link href="/archives/3299158642/"/>
      <url>/archives/3299158642/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><a href="https://www.luogu.org/problemnew/show/P1226" target="_blank" rel="noopener">洛谷P1226</a></p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>看到题解里貌似并没有Python的题解，我来发一个，共两行。</p><p>众所周知，为什么有时候洛谷er们要用Python呢？因为Python里已经包装了很多算法，用在OI中基本上等于打游戏时开外挂。虽然</p><p>对于这道题，Python 3中有一个数学函数pow()，它在help()函数中的说明是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pow(x, y, z=<span class="literal">None</span>, /)</span><br><span class="line">    Equivalent to x**y (<span class="keyword">with</span> two arguments) <span class="keyword">or</span> x**y % z (<span class="keyword">with</span> three arguments)</span><br><span class="line"></span><br><span class="line">    Some types, such <span class="keyword">as</span> ints, are able to use a more efficient algorithm when</span><br><span class="line">    invoked using the three argument form.</span><br></pre></td></tr></table></figure><p><code>x**y % z</code>，这正好就是这道题所用到的算法，所以直接调用<code>pow(b, p, k)</code>就OK了。一般来说，编程语言本身的库函数都会往死里优化，基本上不用担心时间复杂度的问题。（除了某些特别坑的）</p><p>最后要注意的一点就是，很多人提交Python都莫名RE，原因是Python 3的<code>input()</code>函数返回的是字符串，必须用<code>int()</code>转换为整数。如果一行有多个数字，则调用<code>split()</code>方法分割成多个字符串。</p><p>上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = input().split()</span><br><span class="line">print(a[<span class="number">0</span>] + <span class="string">'^'</span> + a[<span class="number">1</span>] + <span class="string">' mod '</span> + a[<span class="number">2</span>] + <span class="string">'='</span> + str(pow(int(a[<span class="number">0</span>]), int(a[<span class="number">1</span>]), int(a[<span class="number">2</span>]))))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「文章转载」赛博空间独立宣言</title>
      <link href="/archives/142292747/"/>
      <url>/archives/142292747/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>　　工业世界的政府，你们这些肉体和钢铁的巨人，令人厌倦，我来自赛博空间，思维的新家园。以未来的名义，我要求属于过去的你们，不要干涉我们的自由。我们不欢迎你们，我们聚集的地方，你们不享有主权。</p><p>　　我们没有民选政府，将来也不会有，所以我现在跟你们讲话，运用的不过是自由言说的权威。我宣布，我们建立的全球社会空间，自然地不受你们强加给我们的专制的约束。你们没有任何道德权利统治我们，你们也没有任何强制方法，让我们真的有理由恐惧。</p><p>　　政府的正当权利来自被统治者的同意。你们从来没有要求过我们的同意，你们也没有得到我们的同意。我们没有邀请你来，你们不了解我们，不了解我们的世界。赛博空间不在你们的疆界之内。不要认为你们可以建造这样一个疆界，好像建造一座公共建筑。你们没有这个能力。这个疆界是一件自然行为，它将从我们的集体行动中生发出来。</p><p>　　你们从来没有参加过我们的大会，你们也没有创造我们的市场财富。对我们的文化，我们的道德，我们的不成文法典，你们一无所知，这些法典已经在维护我们社会的秩序，比你们的任何强制所能达到的要好得多。</p><p>　　你们说我们有问题，你们要解决这些问题。你们用这个借口侵犯我们的领地。你们所宣称的这些问题，许多都不存在。真正冲突出现的时候，不公正出现的时候，我们自己会鉴定它，用自己的方式解决它。我们正在形成我们自己的社会契约。治理将出现，但根据的是我们世界的情况，不是你们的。我们的世界，是不同的。</p><p>　　赛博空间由交易、关系和思想本身构成，它们像一道永恒的波浪，在我们的交流之网上部署着。我们的世界无处不在，又无处可寻，我们的世界不是肉体存在的世界。</p><p>　　我们正在创造一个新世界，人人都可以进入这个世界，而不必考虑由种族、经济力、武力、出生地而来的特权或偏见。</p><p>　　我们正在创造一个新世界，人人、处处可以表达他或她的信仰，无论这种信仰是多么古怪，而不再害怕被强制沉默或强制一律。</p><p>　　你们关于财产、表达、身份、迁徙的法律概念及其关联对我们不适用。这些概念建立在物质的基础上，我们这里没有物质。</p><p>　　我们的身份不涉及肉体，所以和你们不一样，我们不能通过肉体的强制来获得秩序。我们相信，我们的治道将从伦理、明智的自我利益和公益中产生出来。我们的身份可能分布在你们许许多多的法律管辖中。我们全部的立宪文化能够普遍认可的唯一法律就是这样一个法则：己所不欲，勿施予人。我们希望能在这个基础上确立我们特殊的解决方案。但是我们不能接受你们企图强加给我们的解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS-over-HTTPS(DoH)简析与配置</title>
      <link href="/archives/2251452003/"/>
      <url>/archives/2251452003/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文同步发布于 <a href="https://keepthethink.github.io/archives/2251452003/">Heliumの博客</a>，到我的博客阅读体验更佳QwQ</p><h1 id="DNS是什么"><a href="#DNS是什么" class="headerlink" title="DNS是什么"></a>DNS是什么</h1><p>DNS（Domain Name System）是一项网络服务，用途是对全球各个网站的域名进行解析。如果听不懂上面这句话也没关系，接下来会讲解。如果你是网络方面的大牛可以直接跳过或关闭此网页。</p><h2 id="简明易懂的DNS"><a href="#简明易懂的DNS" class="headerlink" title="简明易懂的DNS"></a>简明易懂的DNS</h2><p>举个例子，从前有个叫小明的人（目测此人已累死），开了一家商店。一开始顾客要去购物时,就直接去商店里买。</p><p>但由于网络环境的复杂性，让顾客直接记住地址是不太可能的。（你试试看？）于是就有人动了脑筋，推出了一样类似DNS的服务：你只需要说出地点（小明杂货店），服务商就会开车送你去目的地。</p><p>很多大公司实际上都推出了这份服务，例如阿里，百度，谷歌，Cloudflare等。</p><p>实际网络中的DNS，则是向服务器询问域名，而服务器返回IP地址。</p><p>顺便推荐几个质量好的良心DNS如下：</p><h3 id="Cloudflare-DNS"><a href="#Cloudflare-DNS" class="headerlink" title="Cloudflare DNS:"></a>Cloudflare DNS:</h3><p>1.1.1.1, 1.0.0.1</p><h3 id="Google-Public-DNS"><a href="#Google-Public-DNS" class="headerlink" title="Google Public DNS:"></a>Google Public DNS:</h3><p>8.8.8.8, 8.8.4.4</p><h3 id="OpenDNS"><a href="#OpenDNS" class="headerlink" title="OpenDNS"></a>OpenDNS</h3><p>208.67.222.222, 208.67.220.220</p><h2 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h2><p>看到这里你可能有疑惑了，难道每一台DNS服务器都储存了很多IP地址和域名的对应吗？不是。一这很浪费空间，二这样很难更新。</p><p>以我的博客地址<code>keepthethink.github.io</code>为例，当你输入地址后：</p><p>1.你的电脑首先会去询问DNS服务器；</p><p>这个“DNS服务器”可能在任何地方，可能就在你家的路由器上，也有可能在万里之遥的灯塔国QwQ（如果你是非酋</p><p>当然，一般来讲你的路由器上不会真的有一个DNS服务端，如果你在本地登录912.168.0.1或192.168.1.1，你就会看到在“DNS”设置那一栏会有你的ISP的DNS地址（当然，如果你想把它换成公共DNS也可以，但要为你自己的网速负责。）</p><p>2.DNS服务器询问所谓“根服务器”；</p><p>根服务器询问.io域名的权威服务器；</p><p>.io域名的权威服务器询问.github.io域名的权威服务器;</p><p>.github.io域名的权威服务器将IP告知你的电脑；</p><p>OK</p><p>（这套措施实在是找不到合适的比喻，看不懂就跳过吧。）</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果你访问的是一些比较国际化的网站，而且还使用了国外的DNS服务器，有可能会会给你分配个国外的IP地址。</p><p>举个最基础的例子：Hexo博客在注册网址时，进行的国内外分流。这是不排除某些睿智国外DNS不管三七二十一给你个国外地址的情形。 </p><h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><p>这么干，空间的确节省了很多，但效率显然就更慢了。所以，DNS服务器中一般有个“缓存”，当你重复询问同一个网址时，直接找出缓存记录并答复。当然，每个一定的时间会更新缓存。</p><p>既然这套措施已经很完美了，那DoH是干嘛的？别急，马上就讲。</p><h2 id="DNS劫持与HTTP劫持"><a href="#DNS劫持与HTTP劫持" class="headerlink" title="DNS劫持与HTTP劫持"></a>DNS劫持与HTTP劫持</h2><h3 id="DNS劫持：当DNS不那么老实"><a href="#DNS劫持：当DNS不那么老实" class="headerlink" title="DNS劫持：当DNS不那么老实"></a>DNS劫持：当DNS不那么老实</h3><p>打个比方：</p><p>从前有个叫小刚的，他也开了家杂货店；</p><p>小刚发现小明的杂货店有很多客户，分外眼红，便拿钱贿赂了DNS服务商，于是，当顾客要求DNS服务商将其带到“小明杂货店”是，DNS会不管三七二十一将其带到“小刚杂货店”。在网络中，则是DNS服务器故意给出错误的IP地址。</p><p>这显然是无计可施的，一般来说，遇到这种人品烂的掉渣的服务商，最好的办法就是换一家，好在这年头网络条件不错，大多数DNS都不搞这种事。</p><p><strong>但是</strong>，对于DNS劫持，刚才讲的一种情况并非最常见的，最常见的事下面这种：</p><p>假设只有服务商A收了贿赂，而服务商B没有。当你向DNS服务商B打电话时，你的<strong>电话服务商</strong>将其转接到服务商A，那你就前功尽弃了。唯一的方法是使用DNS-over-HTTPS，后面会讲解。</p><h3 id="HTTP劫持：当ISP不那么老实"><a href="#HTTP劫持：当ISP不那么老实" class="headerlink" title="HTTP劫持：当ISP不那么老实"></a>HTTP劫持：当ISP不那么老实</h3><p>假设你向DNS服务器打了个电话，“我要去小明杂货店。”结果你的电话服务商窃听了这句话，得知了你的行程；甚至将其修改为“我要去小刚杂货店。”，然后你就不明不白的被带到了另一个地方。</p><p>在这种情况下，你的DNS服务商是老实可靠的，但你的ISP（网络服务提供商）则不那么可靠。当然，一般的ISP并没有那么猖狂，他们最多不过是往你身上塞几张奇♂怪♂的广♂告♂（想必大家都有这样的经历。）你有时候会不会发现你看到的广告就是最近曾经关注过的事物？</p><p>你也许会说，可以修改DNS来解决这个问题，但如果你的ISP让 Google Public DNS 跳转到 <em>.</em>.<em>.</em> 之类与其同流合污的DNS地址怎没办？图样图森破。</p><p><strong>注意</strong></p><p>有哪些进行HTTP劫持的ISP？基本上都有：移动，联通，电信，天下乌鸦一般黑，呵呵。<br>一个极其明显的例子如下：</p><p><img src="https://i.loli.net/2019/04/26/5cc2c1cf0d688.jpg" alt="yunyingshangjiechi04.jpg"></p><p>这种劫持的关键在于，DNS服务器与你之间的链接为“明文传输”，而非“加密传输”。这就导致每一个环节上的人都能随意修改你的链接。幸运的是，在生产力高度发达的9102年，加密技术早已像烂柿子一样成熟了，如HTTPS。</p><h1 id="DoH的具体原理"><a href="#DoH的具体原理" class="headerlink" title="DoH的具体原理"></a>DoH的具体原理</h1><p>DoH的具体原理其实就是在DNS外面套一层HTTPS。（而且更慢了）即流程变成了</p><blockquote><p>你的电脑 -&gt; DoH服务器 -&gt; DNS服务器 -&gt; DoH服务器 -&gt; 你的电脑</p></blockquote><p>以上流程中的一个箭头代表一个HTTPS加密链接，使得该过程中的所有流量皆受到强加密，这样一来，除非拖出量子计算机或智子，否则绝无可能被破解。</p><p>（当然，如果HTTPS本身出现漏洞，流量自然就会被破解。但这样一来所有与网络有关的事务都会彻底崩溃，不多你一个。）</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ol><li>本人电脑为macOS + Firefox，亲测有效。</li><li>新疆OIer会因为某些原因而无法使用DoH。</li></ol><h2 id="在Firefox浏览器中体验DoH"><a href="#在Firefox浏览器中体验DoH" class="headerlink" title="在Firefox浏览器中体验DoH"></a>在Firefox浏览器中体验DoH</h2><p>首先，把你的Firefox Quantum更新到最新版。（废话）</p><p>点击右侧的“菜单”，就是那个三条横线的图标；</p><p>在菜单里点击“首选项”；</p><p>进入“常规”选项；</p><p><img src="https://keepthethink.github.io/images/Jietu20190416-142149@2x.jpg" alt></p><p>滚动页面到最下方，选择“网络设置”；</p><p><img src="https://keepthethink.github.io/images/Jietu20190416-142524@2x.jpg" alt></p><p>在弹出窗口的最下方选择“启用基于HTTPS的DNS”，点击“使用默认值”即可。</p><h2 id="在Google-Chrome中体验DoH"><a href="#在Google-Chrome中体验DoH" class="headerlink" title="在Google Chrome中体验DoH"></a>在Google Chrome中体验DoH</h2><p>遗憾的是，直到这篇科普写完时，Chrome仍然不支持直接配置DoH。如果你希望使用Chrome，请参见下面的教程。</p><h2 id="在Windows上使用DoH"><a href="#在Windows上使用DoH" class="headerlink" title="在Windows上使用DoH"></a>在Windows上使用DoH</h2><p>想再Windows上使用DoH？直接安装Firefox不就好了？</p><p>当然，如果你是一名狂信徒，非要使用其他浏览器，我这里倒是有个思路：</p><ol><li><p>买一台服务器，系统是Linux。</p></li><li><p>在服务器上重复“在Linux中体验DoH”中的方案</p></li><li><p>把你的DNS服务器地址设为你的服务器的公网IP地址</p></li></ol><p>当然，可能你自己得花点钱。</p><h2 id="在macOS中体验DoH"><a href="#在macOS中体验DoH" class="headerlink" title="在macOS中体验DoH"></a>在macOS中体验DoH</h2><p>首先，为了安装必要的组件，我们首先要安装Homebrew软件包管理器。在终端中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure><p>安装完成后，输入以下命令安装cloudflared：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install cloudflare/cloudflare/cloudflared</span><br></pre></td></tr></table></figure><p>等待安装，这段时间内你可以去换（chuan）件（shang）衣（nv）服（zhuang）。</p><p>然后，我们要修改一下配置文件，新建一个文件<code>/usr/local/etc/cloudflared/config.yaml</code>，输入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy-dns: true</span><br><span class="line">proxy-dns-upstream:</span><br><span class="line">  - https://1.1.1.1/dns-query</span><br><span class="line">  - https://1.0.0.1/dns-query</span><br></pre></td></tr></table></figure><p>（顺便提一下，如果1.1.1.1和1.0.0.1两个都连不上，可以把网址删除换成<code>https://dns.google.com/experimental</code>试试，</p><p>好了不要吵了我知道这是天方夜谭）</p><p>配置结束，启动服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cloudflared service install</span><br></pre></td></tr></table></figure><p>QED！现在你的电脑已经成了一台DoH服务器，高兴的话你也可以把它当作DNS服务器来用。打开 系统首选项 -&gt; 网络 -&gt; 高级 -&gt; DNS，在列表的最顶端添加 127.0.0.1 即可。</p><h2 id="在Linux中体验DoH"><a href="#在Linux中体验DoH" class="headerlink" title="在Linux中体验DoH"></a>在Linux中体验DoH</h2><p>同macOS，但安装时一定要记得加PPA源～</p><h2 id="DoH的使用测试"><a href="#DoH的使用测试" class="headerlink" title="DoH的使用测试"></a>DoH的使用测试</h2><p>用dig命令测试一下，发现DOH的使用体验还是相当不错的。对域名<a href="http://www.google.com的查询结果如下：" target="_blank" rel="noopener">www.google.com的查询结果如下：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ dig @127.0.0.1 www.google.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; @127.0.0.1 www.google.com</span><br><span class="line">; (1 server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 48175</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 1452</span><br><span class="line">; PAD: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 (&quot;.................................................................&quot;)</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.google.com.INA</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.google.com.66INA216.58.194.196</span><br><span class="line"></span><br><span class="line">;; Query time: 165 msec</span><br><span class="line">;; SERVER: 127.0.0.1#53(127.0.0.1)</span><br><span class="line">;; WHEN: Tue Apr 16 16:33:38 CST 2019</span><br><span class="line">;; MSG SIZE  rcvd: 142</span><br></pre></td></tr></table></figure><p>注意最下方几行：165毫秒的查询时间不可谓不快。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>事实上，如果你饱受各种小广告弹窗之苦，DoH是个不错的应对措施；</p><p>如果你的运营商直接进行DNS劫持，建议投诉或诉诸法律；</p><p>如果你的运营商进行HTTP劫持，推荐DoH。</p><p><strong>点个赞再走吧(๑•́₃ •̀๑)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「文章转载」他译作“维基”的那个网站消失在竹幕后</title>
      <link href="/archives/2552852216/"/>
      <url>/archives/2552852216/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文放弃一切经济权利，各网站、公号和其他各类载体可在保持原文完整的基础上自由转载。</p></blockquote><p>这个周末，维基百科终于整体离我们而去。它的404，意味着13亿人再次被隔离于一个“普世产品”之外。</p><p>Pingwest创始人托马斯·骆在山寨发布会群里分享了他勤奋更新的微信公众号文章，<a href="http://mp.weixin.qq.com/s?__biz=MzAxMzc1NTkwNQ==&amp;mid=400989696&amp;idx=1&amp;sn=d36df590742255b0cb95d054376149d2&amp;scene=25&amp;srcid=1206Z80ZDGf1hSTlJarvNJ9i#wechat_redirect" target="_blank" rel="noopener">《自由和美好的事物总是戛然而止：比如约翰 列侬和维基百科》</a>（点击链接可以访问过去，做好他的公众号无所不谈的准备，虽然都挺有趣的）。</p><p>知乎讨论这个问题的500多个回答在昨天上午戛然而止，消失无踪。托马斯的这篇文字也不知道能生存到何时。互联网这片沃土在别的地方长出了很多参天大树，在中国却总像城市人行道水泥砖之间的野草，顽强地露头，被碾压而过；又螳臂挡车地冒头，再被碾压。周而复始。</p><p>在这些野草之中，我翻出了2010年时采访第一个中文维基百科词条创建者、“维基”这个译名的提出者的随笔。当他以及最早期的维基中文十三人确定这个译名并胼手砥足地一条一条建立起中文维基时，未必能看到这灰暗的未来。但他接受采访时的淡然和话语间隐隐透露出的理想主义，却正是这些年来激励人们前赴后继地传播光明的原动力。</p><p>这篇东西同样不知道能存活多久，所以本文开头我就放弃了关于本文的一切权利，希望尽量多的自媒体、网站和无处不在的SEO页能收录它、转发它，让人知道中文互联网世界一直燃烧不灭的微弱火种。即使不转发，也可以把它发到邮箱里，存到梯子通达的墙外，在隐秘的一个个圈子里流传。在历史无法书写之处，我们口口相传。仿佛华氏451那个时代，消防员以焚书为业；但热爱文字的人们仍然找到办法，他们分工合作，背下了每一本人类历史的名著；他们</p><blockquote><p>跟普通人没什么两样，像是跑完了一段长路，经过漫长的寻觅，见过美好的事物被焚毁，如今已垂垂老矣，聚在一起等待曲终人散，灯干油尽。他们并不肯定自己脑中所记载的一切，能使未来每一个日出发出更纯净的光辉，他们对此并无把握。但他们确知，那些书储存在他们平静的眼眸之后，完好无缺地等待着将来某一天，那些手指干净或肮脏的读者再来翻动。</p></blockquote><p>以下为原文。斜体字为今日所加。</p><p><strong>那些改变中国互联网的小人物之一：维基百科命名者苑明理</strong></p><p>2002年10月24日，苑明理（维基用户名 mountain）撰写了第一个具有中文内容的维基百科主页。</p><p>此前，或许有其他用户也曾想尝试，但当时的维基主页不支持中文输入。借由工具软件，mountain巧妙地绕过了这个障碍。维基媒体基金会发现了这个微小但意义深远的变化，三天后，中文维基百科有了自己的服务器、域名，同时，后台程序也升级为支持中文输入的版本。世界上最大的百科全书与使用人口最多的语言成功握手。作为中文维基百科的第一位参与用户，苑明理启动了这一进程。</p><p>在完成了第一篇中文条目“计算机科学”后，苑明理又提出了中文命名的提案。尽管已经有了中文内容，但这个百科全书的命名仍然用英文名字Wikipedia。 当时正在北大读应用数学研究生的苑明理引经据典，提出以“维基百科”作为Wikipedia的中文名称。苑明理向淼叔解释了当时的思路：“维”的本意是系物的大绳，由“纲举目张”转引到“网”的含义。而在此前，“万维网”作为WWW流传最广中文译名，已经认可了“维”与互联网的对应；“维基百科”，基于互联网的百科全书，这个译名成为Web2.0概念中音义俱佳的翻译，其流行程度仅次于“博客”（但后者并未得到普遍认同，现在仍有大量业者坚持称为“网志”）。一年之后的2003年10月，中文维基的13个管理员用户投票决定正式中文名，其中有9人选择了“维基百科”。在今天看来，这次投票的意义堪比埃尔隆德会议。</p><p>发布首个维基百科中文条目，以及命名维基百科，这两项里程碑式工作，完成任何一项都可以在IT史甚至学术史上留名；但苑明理并不认为这些有多么重要。 “我不做，总有人会做。当时国内已经有一些人在英文维基上学习了。至于命名，其实当时参与投票的其他译名也有很不错的”。很难说这是一种故作姿态的谦虚， 因为相比浩淼如海的维基百科，无论是参与者，还是使用者，都会为海量的知识目眩神迷。</p><p>Wikipedia 自2001年在美国建立以来，迄今已经拥有1200万个以上的条目，最大的英文维基拥有316万个条目（大英百科全书不到七万条）；中文维基自建立以来， 也已经拥有将近30万个条目。截至2007年10月，维基百科已经经历了四亿次编辑。相对地，维基的注册用户达1500万之众——要知道，维基百科的查阅甚至修改都无需注册。</p><p>在这些数据背后，是仍然不断汇聚而来的知识，更多的编辑者，更多的条目，更多次搜索。苑明理参与维基社区时，中文用户寥寥，条目也以编译英文条目为主。“维基”之译名，自提案而至表决，长达一年。倒并非是争论激烈，而是一开始人数太少，不好遽然而定。“中文维基属于所有中文用户，人数太少时定下名字，对其他人不是很不公平。”</p><p>苑明理坦承，维基所倡导的民主与自由，对其自身影响很大。维基的原则是每一个人均可参与编辑，人人平等；由于每一个人均可以编辑条目、增删内容，因此所有用户在维基面前平等。即使作为开创者和管理员，苑明理也并未享有太多的特权。管理员所作的，更多是维持编辑秩序，锁定或清理恶意编辑者。而对条目的修改，管理员与普通用户权限并无不同，都需要反复讨论、辨析，表明观点。这使维基的管理员远远不像一些论坛版主那样跋扈，所有参与者的讨论反映到条目上，也显得冷静而客观。</p><p>早期参与编辑维基的用户，素质都较为卓越。“我从他们身上学到了很多。”苑明理很怀念一位新加坡籍管理员，后者致力于中文维基社区规则的建立与完善。维基开放给所有用户编写，汇聚知识领域的微力量，带来的副作用可能是信息杂化，和编辑者之间的争吵。既然管理员不能以权威压人，此时便需要依规则调解。另有管理员引入“共识”的标准，成为解决条目争议的重要规则。</p><p>“早期中文维基的管理者贡献良多。”苑明理回忆。他们贡献的不止是中文条目，更在于及时将中文维基解决争端、协调众声的机制和规则建立起来。作为一个参与者几乎无限的项目，维基能够在高速增长的同时，仍维持条目令人惊奇的准确与中立，规则之完善与争端调解机制的建立，功不可没。</p><p>在飞速发展的同时，维基百科也并非没有遇到障碍。尽管拥有世界上最高超的调和艺术和顶尖人才，但维基仍然常常爆发“编辑战”，即各位编辑者就词条的表达与取舍进行的激烈论战。较为典型的是，伊朗现任总统内贾德的词条，从他还是一个默默无闻的候选人时就出现在百科页面上，随着他仕途的通达和不断发表的争议性言论，维基内部也一次次爆发论战。他的哪些言行需要载入页面，哪些判断适合进入百科，“每一个字上都展开了殊死搏斗”。</p><p>内贾德代表了世界上所有尖锐的冲突：东方主义下的东西方冲突，文明冲突论下的伊斯兰文明与基督教文明冲突，政治学意义下的学者与政客的冲突。反映到维基百科上，就是长达三年的争吵，三个调解员因此去职，单一个积极用户就作了近400次修改；最后完成的词条力争记录了内贾德的言论，却仍然被指责为“过长，但没有信息量”。筋疲力尽的维基人们告诉后来者：“可以重新开始讨论……可是我们已经没有精力再参与”（本段内容参考了南方都市报的相关报道）。</p><p>中文维基百科面临相似的困扰，据mountain回忆，有时他甚至声称要因此退出维基项目。与大部分争吵的原因不同，对内容的讨论主要围绕中立原则，只不 过各方对“中立”的理解不同。维基的词条就是在这样严格得近乎苛刻的审查中诞生，每一个词条看上去都冷淡，平静，客观，不带任何感情色彩和倾向。维基的编写是天下大同的缩写，呈现出来的结果却是万籁俱寂的白描。“维基最大的特点，就是在规则之下的众声喧哗，直到共识。”苑明理总结。</p><p>除了内容上的争论，中文维基还面临许多“特色国情”的挑战。作为百科全书，基本目的就是无所不包，除了“根据当地的法律法规不予显示”的内容。但是，当法律法规并未明确规定内容的界限时，无所不包就成为一种冒险的行为。中文维基百科自2005年后，访问上始终存在一些滞涩。有时一些页面会载入后无法显示，有 些时候则干脆整站无法访问。在这段时间，百度百科、互动百科等国产百科开始占领市场。</p><p>在注意力就是资源的互联网，苑明理对这种蚕食并不是太在意。“维基百科不会死，其他山寨版不尊重版权，随意拷贝媒体内容，没有真正创作和学习的乐趣，对维基百科不会形成真正威胁。”似乎是为了证明这一点，科普作家方舟子在博客上发文，痛斥国内某搜索引擎的在线百科不尊重版权，随意剽窃他文章的内容，还设置了繁琐的投诉程序。</p><p>“海纳百川，有容乃大”是中文维基百科的副标题，苑明理似乎从这句话中获得了更多从容的力量。“英文维基不会死，维基用户数量就有了保障。竞争再激烈，时间总会说明一切。坚持中立、包容和分享知识的乐趣，维基精神就不灭。”在关于维基你或许不知道的十件事这个条目下，最后一条就是“维基是一个百年大计”。既然能长寿到所有敌人都死去，那还有什么值得焦躁和忧愁呢？</p><p>“维基汇聚了所有普通人的力量，分享着所有用户的知识，并以此为基础记录人类文明的成果。”苑明理终于谈到了自己的理想：“这就是我想要的，世界公民。”</p><p>补记：苑明理已经于三年前离开了他服务多年的国际IT巨头。现在他在知春路的一家创业公司中埋头做一款叫做“彩云天气”的产品。除此之外，生活没有任何变化。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷题解 P1003 【铺地毯】</title>
      <link href="/archives/1438989892/"/>
      <url>/archives/1438989892/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到$n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。</p><p>地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入共$n+2$行</p><p>第一行，一个整数$n$，表示总共有$n$张地毯</p><p>接下来的$n$行中，第 $i+1$行表示编号ii的地毯的信息，包含四个正整数$a ,b ,g ,k$ ，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标$(a,b)$以及地毯在$x$轴和$y$轴方向的长度</p><p>第$n+2$行包含两个正整数$x$和$y$，表示所求的地面的点的坐标$(x,y)$</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>输出共$1$行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出$−1$</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h2><p>3</p><p>1 0 2 3</p><p>0 2 3 3</p><p>2 1 3 3</p><p>2 2</p><h2 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h2><p>3</p><h2 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例#2："></a>输入样例#2：</h2><p>3</p><p>1 0 2 3</p><p>0 2 3 3</p><p>2 1 3 3</p><p>4 5</p><h2 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例#2："></a>输出样例#2：</h2><p>-1</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【样例解释1】</p><p>如下图，11 号地毯用实线表示，22 号地毯用虚线表示，33 号用双实线表示，覆盖点(2,2)(2,2)的最上面一张地毯是 33 号地毯。</p><p>【数据范围】</p><p>对于30% 的数据，有 $n ≤ 2$ ；<br>对于50% 的数据，$0 ≤a, b, g, k≤100$；<br>对于100%的数据，有 $0 ≤n ≤10,000$ ，$0≤a, b, g, k ≤100,000$。</p><p>noip2011提高组day1第1题</p><h1 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h1><p>看标签<br><strong>枚举，模拟，暴力</strong>。</p><p>很容易想到开一个大小N * N 的二维数组，然而数据范围是0 ≤ N ≤10,000</p><p>数组大小：10000 * 10000 = 100000000 Byte = 100000 KB = 100MB</p><p>刚好跨过了RE与MLE的红线。</p><p>另外一种方法是用四个数组来记录长方形的四个参数，再扫一遍检查最上面的地毯。</p><p>亲测，完美AC。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">5</span>;<span class="comment">//程序里出现幻数可不是好习惯哦~</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN], b[MAXN], g[MAXN], k[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, x, y;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;a[i], &amp;b[i], &amp;g[i], &amp;k[i]);<span class="comment">//输入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= a[i] &amp;&amp; y &gt;= b[i] &amp;&amp; x &lt;= a[i] + g[i] &amp;&amp; y &lt;= b[i] + k[i]) &#123;</span><br><span class="line">            ans = i + <span class="number">1</span>;<span class="comment">//ans的最终值恰好是最上面的那张地毯编号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);<span class="comment">//输出结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人类首张黑洞照片</title>
      <link href="/archives/2078626702/"/>
      <url>/archives/2078626702/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>2019年4月10日9：00，人类首张对黑洞进行直接拍摄的照片发布。</p><p><img src="https://i.loli.net/2019/04/12/5cb090dea8dcc.jpg" alt></p><p>这张照片可能并不符合许多人想象中常见的“漩涡”形象，但这是最符合目前学术界公认理论的形象。爱因斯坦，史瓦西，克尔，霍金等历代科学家的理论终于在这一天得到了论证，只不过他们都没有活到看到他们预言之物终于被光学设备记录到的那一天。</p><p>“黑洞”这个概念在20世纪就早已名扬四海，但这个概念一直只是存在于物理学家的计算中，这多少让人想起海王星，但海王星被计算出后几乎是立刻就被天文望远镜所发现，而黑洞从被计算出（1915年12月德国天文学家卡尔·史瓦西计算出爱因斯坦方程的黑洞解。）到2019年黑洞终于被人类的天文望远镜拍摄到，时隔整整103年。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 天文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷题解 P1002 【过河卒】</title>
      <link href="/archives/2197869946/"/>
      <url>/archives/2197869946/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>棋盘上$A$点有一个过河卒，需要走到目标$B$点。卒行走的规则：可以向下、或者向右。同时在棋盘上$C$点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。</p><p>棋盘用坐标表示，$A$点$(0, 0)$、$B$点$(n, m)$($n$, $m$为不超过$20$的整数)，同样马的位置坐标是需要给出的。</p><p>现在要求你计算出卒从$A$点能够到达$B$点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>一行四个数据，分别表示$B$点坐标和马的坐标。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>一个数据，表示所有的路径条数。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h2><p>6 6 3 3</p><h2 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h2><p>6</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>结果可能很大！</p><hr><p>看到题目二话不说用了搜索，直到在提交前看了一下算法标签，又看了一下数据范围。。。</p><p>状态转移方程的推导并不复杂，每次判断卒是否能走到这个格子，不可以则为0（显而易见），可以则为下方与左方的值之和。</p><p>上代码，这道题算是一道DP入门题吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">20</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> attack[<span class="number">9</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dist[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m, x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x + attack[i][<span class="number">0</span>] &lt;= n &amp;&amp; x + attack[i][<span class="number">0</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(y + attack[i][<span class="number">1</span>] &lt;= m &amp;&amp; y + attack[i][<span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">map</span>[x + attack[i][<span class="number">0</span>]][y + attack[i][<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;x, &amp;y);</span><br><span class="line">    </span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dist[i][<span class="number">0</span>] = <span class="built_in">map</span>[i][<span class="number">0</span>] ? k = <span class="number">0</span> : k;</span><br><span class="line">    &#125;</span><br><span class="line">    k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        dist[<span class="number">0</span>][i] = <span class="built_in">map</span>[<span class="number">0</span>][i] ? k = <span class="number">0</span> : k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dist[i][j] = <span class="built_in">map</span>[i][j] ? <span class="number">0</span> : dist[i - <span class="number">1</span>][j] + dist[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dist[n][m]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理性看待CCF</title>
      <link href="/archives/2538557693/"/>
      <url>/archives/2538557693/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>先说结论：CCF的问题在于，他们在OIer们需要时无法提供帮助，在自己需要时却一点都不为OIer们考虑。</p><p>几个月过去了，关于CCF的一切事件基本上都已经风平浪静。</p><p>从事实角度来讲，CCF的<strong>大部分</strong>行为是无可厚非的，CCF垄断国内OI界并不停抬价，由于OI不属于商业范畴，似乎不违反现有任何法律；抬价，似乎也没有抬到诸位承担不起的地步。当然，这些报名费里面有多少用于比赛举办，可能还得打个问号，但这里要注意两点：</p><ol><li>CCF不是政府机构，也就是说他们并不是广大OIer们的公仆，不像我们交的税，全部都用于国家发展与建设。</li><li>CCF这么个庞然大物一般的组织若要运转，需要很大一笔资金。</li></ol><p>其实NOIP2018时CCF就已经将评测机换成了i7-8700K 32GB RAM，但其耗费的资金必然只占我们的报名费中的一小部分。[1]简单估计一下，这台电脑撑死也就……5万？10万？但考虑到这之前的两点，这也不是什么奇怪的事。说实话，这并不会影响到我们OIers的生活，后面说到的才是真正重要的问题。我们每年交了几百万上千万了，已经相当于一个中型企业的年收入。一言以蔽之，“把CCF的财务部门与CCF的竞赛组织部门的人对调，CCF的所有问题都会得到解决。”</p><p>既然CCF激起如此民愤，说他们什么亏心事都没做未免说不过去。只是要告诉屏幕前的各位，在对CCF进行道德判断时，应该以一种更为中肯的角度去看待。</p><h1 id="关于省队名额"><a href="#关于省队名额" class="headerlink" title="关于省队名额"></a>关于省队名额</h1><p>先谈省队。省队是什么？</p><p>省队是各省参加全国赛的代表队，各个省队的名额有复杂的计算公式，一般和之前的成绩和参赛人数有关。[2]</p><p>省队相当于什么难度？以下几个知识点取自“洛谷试炼场”：</p><ul><li>网络流</li><li>单调队列</li><li>概率期望</li><li>二分图</li><li>点分治</li><li>后缀数组</li><li>主席树</li><li>数位DP</li><li>AC自动机</li><li>平衡树</li><li>树链剖分</li><li>动态树</li><li>树套树</li><li>可持久化Trie树</li><li>莫队</li><li>分块</li><li>莫比乌斯反演</li></ul><p>要让以上知识点全部过关，刷题什么的暂且不提，文化课必定已经彻底停了。（不排除有同时AK文化课的大佬的存在，但这毕竟是个案。）在这种情况下，这位OIer必然是已经将自己的全部前途作为筹码押在了OI这条路上，要么是极其的热爱信息学，要么是坚信自己必然能夺魁榜首。几年来在各大OJ上留下的AC记录，几年来的无数个不眠之夜，几年来留下的汗水，却全都因为一句简单的“有复杂的计算公式，一般和之前的成绩和参赛人数有关”就被一笔勾销！在我们眼里这是个悲剧，在CCF眼里这想必就是一个统计数字！（魔改自斯大林某句被后人强行断章取义的话）</p><p>自法国大革命以后，世界的的主流价值观便是人文主义。人文主义的核心是什么？人是世界的中心！当我们判断一个OIer能否参加省选时，我们应该判断TA作为<strong>一个人</strong>的真才实学，而不是什么复杂的计算公式得到的数目！今天██省因为[数据删除]被减了名额，明天██省又因为[数据删除]被减了名额，其中到底有多少是我们广大OIer的过错呢？CCF吸金什么的倒不是主要问题，但他们到底要不要把OIer的前途放在眼里？</p><p><a href="http://www.noi.cn/newsview.html?id=625&amp;hash=B319A4&amp;type=1" target="_blank" rel="noopener">CCF关于NOIP2017复赛违规省份的处罚公告</a></p><p>呵呵，通报批评一下就了事了，真当我们是傻子？而且这不是重点，提高分数线是怎么回事？</p><p><a href="http://www.noi.cn/newsview.html?id=568&amp;hash=8139FE&amp;type=1" target="_blank" rel="noopener">CCF 关于NOIP2016违规事件的处罚公告</a></p><p>处罚作弊者是理所当然的，但整个学校禁赛一年？喵喵喵？这是退回的封建时代了，诛九族？</p><p>若一个省发生了作弊等乱象，犯错的是什么？在CCF眼里，犯错的主体是这个省，所以惩罚就降临到了这个省的头上：扣省队名额。请问在此项举措中，受害最大的是谁？好吧，从现实角度来讲，CCF这么大一个组织，即便是杜子徳也不是想改就能改的。但请问在CCF眼里，我们OIer到底是什么？</p><h1 id="NOIP2018初赛的那些事儿"><a href="#NOIP2018初赛的那些事儿" class="headerlink" title="NOIP2018初赛的那些事儿"></a>NOIP2018初赛的那些事儿</h1><p>首先放链接：<br><a href="http://www.noi.cn/newsview.html?id=760&amp;hash=02E485&amp;type=1" target="_blank" rel="noopener">CCF关于公布NOIP2018初赛违规事件的处罚公告</a></p><p>毫无疑问，这事引起的争议相当的大，俞x颜也瞬间名扬天下，放眼望去遍地都是各种“俞x颜是我同学”之类的回复。扯远了，让我们先把视线聚焦在第一个事件上：</p><h2 id="山东赛区违规情况及处罚通报"><a href="#山东赛区违规情况及处罚通报" class="headerlink" title="山东赛区违规情况及处罚通报"></a>山东赛区违规情况及处罚通报</h2><p>相比民主烈士俞x颜的事迹，这起事件反而不那么引人注目。但要注意的是，这起事件波及的是整个省的名额，而浙江的事件只波及到了一个人。</p><p>CCF在处理这起事件的时候，逻辑似乎是这样的：</p><ol><li>山东赛区青州考点（青州二中）负责人潍坊青州市电化教育中心田志杰擅自提前比赛时间</li><li>山东省计算机学会对竞赛相关责任人培训不足，应对此事负责任</li><li>对山东省进行处罚，故对山东省名额进行扣除</li></ol><p>还是那句话：在对一个省的处罚中，利益真正受到损害的是谁？CCF就算没有专心致志办比赛的诚意，起码也应该注意到谁是无辜的！如果因为选手作弊而引起“灭族”至少还可以用CCF的逻辑硬解析过去，这种因为<strong>负责人</strong>行为不当而引起的问题还要扣名额，emmmm</p><h2 id="浙江赛区违规情况调查及处罚通报"><a href="#浙江赛区违规情况调查及处罚通报" class="headerlink" title="浙江赛区违规情况调查及处罚通报"></a>浙江赛区违规情况调查及处罚通报</h2><blockquote><p>10月16日， CCF接到实名举报，指出浙江赛区出现影响比赛秩序的行为，经调查核实，情况属实。</p></blockquote><p>“出现影响比赛秩序的行为”？请问具体怎么样才算出现影响比赛秩序？有相关规定么？情况属实？这不等于开门还没见山，就先给人家俞x颜扣帽子吗？</p><blockquote><p>在竞赛前一天，10月12日15:29，余姚中学选手俞x颜（女）在网上发布名为“NOIP2018提高组初赛解析”的博客，13日下午初赛结束后，俞x颜从网上获取NOIP2018提高组初赛答案PDF版本后上传至“NOIP2018提高组初赛提高组解析”博客内。经验证，该博客网站不会显示更新的时间，而只显示该条博客内容首次发布的时间。因此，俞x颜的这一行为造成了NOIP2018提高组初赛答案泄露的假象。</p></blockquote><p>所以说，这是假象？真是让人白高兴一场。</p><p>请问CCF，哪条条例规定了不能制造假象？当然了，这是我们可以援引万能的<strong>第八条条例</strong>：</p><blockquote><p>选手违规行为是指：</p><p>1)      将不允许夹带的物品带入考场并经指出后仍不予改正；</p><p>2)      在考场通过不正当途径获得与竞赛有关的信息或为其他选手提供与竞赛有关的信息；</p><p>3)      用不正当途径和介质将答案带入考场；</p><p>4)      以不正当方式提前得到竞赛题目；</p><p>5)      让他人替代参加竞赛或以他人或其他单位的名义参加竞赛；</p><p>6)      抄袭或拷贝他人的答案或程序，有意提供给他人答案或程序；</p><p>7)      不遵守竞赛规则和赛场规定；</p><p>8)      其他可能影响公平竞赛的其他行为。</p></blockquote><p>其他可能影响公平竞赛的其他行为。</p><p>Sorry，负责制定规则真的可以为所欲为。</p><blockquote><p>“NOIP2018提高组初赛解析”博客一事系选手“俞x颜”（女）为吸引网上点击量而做出的行为，<strong>俞x颜本人也予以承认</strong>。她的这一行为在选手中造成一定的恐慌和混乱，干扰了正常的竞赛秩序，有损竞赛的声誉，也给组织方带来不必要的负担和干扰。</p></blockquote><p>本人予以承认？俞同学啊，你既然有在CCF眼皮底子下玩火的觉悟，就应该有不被屈打成招的觉悟吧。你要是斩钉截铁地说就是先占坑等会来填，CCF也不至于把你弄成这样。</p><p>当然，从这里并不能看出俞同学是不是真的留下口实了，也许她根本没说也不一定。</p><blockquote><p>NOIP是CCF主办的NOI系列赛事之一。公平公正是竞赛的生命，任何违规行为对竞赛都是极大的伤害。CCF NOI各相关机构会带头遵守规则，严格保密，同时也承担维护竞赛公平公正良好秩序的重任，对任何违规或作弊的行为均按竞赛条例给予严肃处理。NOI各组织单位、学校、教师均要严格按照规定和流程开展工作，诚实守信，保证赛事的公正进行。</p></blockquote><p>刚泼完脏水又来扣帽子？人家俞同学哪里破坏公平公正了？退一万步说。即使“引起恐慌”了，“破坏公平公正”是什么意思？偷换概念吗？</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里引用一位大佬（非OI界）的话：</p><blockquote><p>用伤害无辜者来掩盖自己的错误是心虚的体现，也永远掩盖不了。 ——Hannah_AI [3]</p></blockquote><p>综上所述，俞同学的所作所为只不过是发博客的事件提前了一点而已，只要点进去就可以知道发生了什么。（当然，初赛完成之后可能有一点点误会，但俞同学肯定在自己的博客里注明了。）恐慌？历史上有过OIer恐慌的事吗？</p><p>CCF在此次事件中的行为，目的是什么？目的就是突出CCF在处理关于OI的问题之公正。实际上，这起到作用了吗？</p><p>CCF，你到底是想干嘛？把一个活生生的人当作垫脚石吗？</p><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p><strong>为什么CCF老是被人喷？因为他们在OIer们需要时无法提供帮助，在自己需要时却一点都不为OIer们考虑。</strong></p><p>一个负责中国OI的组织，不应该是这样。</p><p>关于CCF的事，应该以一种理性的方式去看待。</p><p><img src="https://pic2.zhimg.com/80/v2-9a49f4e1981a4653446d9b165c43a7c5_hd.jpg" alt></p><p>以上就是个完美的反面教材</p><p>像 China Chasing-money Foundation 这种为黑而黑，真的能为广大OIer的权利起到什么帮助吗？并没有。</p><p>那么，我们到底可以为此做些什么？什么也做不了。</p><h1 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h1><h2 id="所谓“吃人”"><a href="#所谓“吃人”" class="headerlink" title="所谓“吃人”"></a>所谓“吃人”</h2><p>吃人是什么？先想自己的利，再想别人的命，便是吃人。</p><h2 id="所谓“连坐”"><a href="#所谓“连坐”" class="headerlink" title="所谓“连坐”"></a>所谓“连坐”</h2><p>连坐是野蛮人的象征，譬如诛九族与扣省队名额。</p><p>方孝孺至少还有个成王败寇的说法，他的弟子，门生们做错了什么？</p><h2 id="《第八条条例》"><a href="#《第八条条例》" class="headerlink" title="《第八条条例》"></a>《第八条条例》</h2><blockquote><p>选手违规行为是指：</p><p>1)      将不允许夹带的物品带入考场并经指出后仍不予改正；</p><p>2)      在考场通过不正当途径获得与竞赛有关的信息或为其他选手提供与竞赛有关的信息；</p><p>3)      用不正当途径和介质将答案带入考场；</p><p>4)      以不正当方式提前得到竞赛题目；</p><p>5)      让他人替代参加竞赛或以他人或其他单位的名义参加竞赛；</p><p>6)      抄袭或拷贝他人的答案或程序，有意提供给他人答案或程序；</p><p>7)      不遵守竞赛规则和赛场规定；</p><p>8)      其他可能影响公平竞赛的其他行为。</p></blockquote><p>嘿我有个写小说的点子，《第八条条例》，我想它一定比《第二十二条军规》更好。</p><h2 id="将心比心"><a href="#将心比心" class="headerlink" title="将心比心"></a>将心比心</h2><p>中国的OIers若何CCFers对调一下位置，OI界所有问题都会得到解决。</p><p>（大家别光顾着指责CCF，试想若他们跑路了，我们吃什么？）</p><p>（国人别光顾着指责清政府，试想他们跑路了，国人吃什么？）</p><p>（德国人别光顾着指责纳粹，试想如果在工业发展期间他们跑路了，你们吃什么？）</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://news.mydrivers.com/1/593/593774.htm" target="_blank" rel="noopener">Intel盒装处理器大涨价：i7-8700K涨至2999元 - 快科技 - 驱动之家</a></p><p>[2] <a href="https://oi-wiki.org/intro/mode/" target="_blank" rel="noopener">OI赛事和赛制</a></p><p>[3] <a href="http://scp-wiki-cn.wikidot.com/scp-cn-601" target="_blank" rel="noopener">SCP-CN-601</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算几何：凸包</title>
      <link href="/archives/704167021/"/>
      <url>/archives/704167021/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于初学计算几何的OIer来说，Graham算法是个不错的凸包算法。Graham算法相比极角排序法来说，更为直观也更容易理解。</p><h1 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line"></span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>):x(x), y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Point(Point a, Point b) &#123;</span><br><span class="line">        <span class="comment">//构造从a到b的向量</span></span><br><span class="line">        x = b.x - a.x;</span><br><span class="line">        y = b.y - a.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">const</span> Point&amp; p)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算从自身到点P的距离</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> Point&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">//计算向量叉积</span></span><br><span class="line">        <span class="keyword">return</span> x * p.y - p.x * y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">//按照X轴排序</span></span><br><span class="line">        <span class="keyword">return</span> (x == p.x) ? (y &lt; p.y) : (x &lt; p.x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream&amp; in, Point&amp; p) &#123;</span><br><span class="line">        <span class="comment">//重载 &gt;&gt; 运算符使得cin可以输入</span></span><br><span class="line">        in &gt;&gt; p.x &gt;&gt; p.y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">Point p[MAXN];</span><br><span class="line"><span class="keyword">int</span> st[MAXN], top = <span class="number">-1</span>; <span class="comment">//点栈</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br></pre></td></tr></table></figure><h1 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123; <span class="comment">//输入所有点</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    input();</span><br><span class="line">    sort(p, p + n); <span class="comment">//对点进行直角坐标排序􏰣􏰳􏰣􏰳􏰮􏰂</span></span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    st[++top] = <span class="number">0</span>; <span class="comment">//将第一个点入栈</span></span><br><span class="line">    st[++top] = <span class="number">1</span>; <span class="comment">//将第二个点入栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="function">Point <span class="title">u</span><span class="params">(p[st[top - <span class="number">1</span>]], p[st[top]])</span></span>; <span class="comment">//计算栈顶两个点构成的向量</span></span><br><span class="line">        <span class="function">Point <span class="title">v</span><span class="params">(p[st[top]], p[i])</span></span>; <span class="comment">//计算当前点与栈顶构成的向量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(u * v &lt; <span class="number">0</span>) &#123; <span class="comment">//若叉积小于0</span></span><br><span class="line">            <span class="keyword">if</span>(top == <span class="number">0</span>) &#123; <span class="comment">//当栈中只有一个元素时，退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            top--; <span class="comment">//弹出栈顶</span></span><br><span class="line">            u = Point(p[st[top - <span class="number">1</span>]], p[st[top]]); <span class="comment">//更新</span></span><br><span class="line">            v = Point(p[st[top]], p[i]); <span class="comment">//更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        st[++top] = i; <span class="comment">//将第i个点压入栈中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= top - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ans += p[st[i]].dist(p[st[i + <span class="number">1</span>]]); <span class="comment">//累加下半个凸包的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    top = <span class="number">-1</span>; <span class="comment">//清空栈</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求出上半个凸包，与前半部分大同小异</span></span><br><span class="line">    st[++top] = <span class="number">0</span>;</span><br><span class="line">    st[++top] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="function">Point <span class="title">u</span><span class="params">(p[st[top - <span class="number">1</span>]], p[st[top]])</span></span>;</span><br><span class="line">        <span class="function">Point <span class="title">v</span><span class="params">(p[st[top]], p[i])</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(u * v &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(top == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            top--;</span><br><span class="line">            u = Point(p[st[top - <span class="number">1</span>]], p[st[top]]);</span><br><span class="line">            v = Point(p[st[top]], p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        st[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= top - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ans += p[st[i]].dist(p[st[i + <span class="number">1</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">    top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; fixed &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//控制精度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Splay学习笔记</title>
      <link href="/archives/1401793044/"/>
      <url>/archives/1401793044/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>伸展树（英语：Splay Tree）是一种能够<strong>自我平衡</strong>的二叉查找树，它能在均摊O(log n)的时间内完成基于伸展（Splay）操作的插入、查找、修改和删除操作。</p><p>众所周知，普通BST在进行各种操作时很容易因为左子树与右子树高度差的问题导致时间复杂度退化为O(n)，Splay为了避免这个问题，使用了一种叫做“伸展”的操作来使左右子树平衡，在后面会介绍。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p><code>node.v</code>：节点node的值</p><p><code>node.father</code>：节点node的父节点</p><p><code>node.ch[0]</code>与<code>node.ch[1]</code>：节点node的左子节点与右子节点</p><p><code>node.size</code>：以节点node为根节点的子树的节点总数</p><p><code>node.cnt</code>：数值与节点node相同的节点的数量（都储存在节点node中）</p><p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v, father, ch[<span class="number">2</span>], size, cnt;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> father = <span class="number">0</span>, <span class="keyword">int</span> size = <span class="number">0</span>, <span class="keyword">int</span> cnt = <span class="number">0</span>):v(v), father(father), size(size), cnt(cnt) &#123;</span><br><span class="line">        ch[<span class="number">0</span>] = ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><code>root</code>：根节点</p><p><code>cnt</code>：总结点数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node node[MAXN];</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="pushup"><a href="#pushup" class="headerlink" title="pushup"></a>pushup</h3><p><code>pushup()</code>函数：<strong>更新</strong>节点p的<code>size</code>值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    node[p].size = node[node[p].ch[<span class="number">0</span>]].size + node[p].cnt + node[node[p].ch[<span class="number">1</span>]].size; <span class="comment">//节点数 = 左子树节点数 + 本身的节点数 + 右子树节点数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><p><code>check()</code>函数：询问节点p是其父节点的左子节点还是右子节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node[node[p].father].ch[<span class="number">0</span>] == p ? <span class="number">0</span> : <span class="number">1</span>; <span class="comment">//0代表左子节点，1代表右子节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p><code>connect()</code>函数：将节点x连接为节点f的子节点，方向为d (d = 0, 1，同上)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    node[f].ch[d] = x; <span class="comment">//将节点f的子节点设置为x</span></span><br><span class="line">    node[x].father = f; <span class="comment">//将节点x的父节点设置为f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><h3 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h3><p>旋转是平衡树最主要的操作，其本质在于，每次进行旋转时，左右子树当中之一高度 -1，另外一棵高度 +1，以达到平衡的目的。</p><p>左旋：</p><p>第一次连边，节点x的子节点成为x的父节点的右子节点</p><p>第二次连边，节点x成为节点x的父节点的父节点的子节点，方向与x的父节点相同</p><p>第三次连边，节点x的父节点成为节点x的左子节点</p><p><img src="https://keepthethink.github.io/images/left_rotate.jpg" alt></p><p>右旋：</p><p>第一次连边，节点x的子节点成为x的父节点的左子节点</p><p>第二次连边，节点x成为节点x的父节点的父节点的子节点，方向与x的父节点相同</p><p>第三次连边，节点x的父节点成为节点x的右子节点</p><p><img src="https://keepthethink.github.io/images/right_rotate.jpg" alt></p><p>旋转操作只与标为红，蓝，绿的三个部分有关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = node[x].father, z = node[y].father, d = check(x), w = node[x].ch[d ^ <span class="number">1</span>]; <span class="comment">//w判断应该左旋还是右旋</span></span><br><span class="line">    connect(w, y, d); <span class="comment">//第一次连边，节点x的子节点连接到x的父节点，方向与节点x相同</span></span><br><span class="line">    connect(x, z, check(y)); <span class="comment">//第二次连边，节点x连接到节点x的父节点的父节点，方向与x的父节点相同</span></span><br><span class="line">    connect(y, x, d ^ <span class="number">1</span>); <span class="comment">//第三次连边，节点x的父节点连接到节点x，方向与节点x原先的方向相反</span></span><br><span class="line">    pushup(y); <span class="comment">//更新子树</span></span><br><span class="line">    pushup(x); <span class="comment">//更新子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="伸展"><a href="#伸展" class="headerlink" title="伸展"></a>伸展</h2><h3 id="splay"><a href="#splay" class="headerlink" title="splay"></a>splay</h3><p>Splay操作：将节点x旋转到节点dist的子节点。通常是将该节点旋转到根节点，在这种情况下，应当将<code>root</code>置为x</p><p>最朴素的想法：只要父节点不是dist就一直旋转该节点，但这样很容易被某些机（wu）智（liang）出题人卡。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dist = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(node[x].father != dist) &#123;</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist == <span class="number">0</span>) &#123;</span><br><span class="line">        root = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，在实际操作中，通常会预判节点x的父节点的方向，若方向一致则旋转其父节点，减少被卡的可能性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dist = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> f = node[x].father; f = node[x].father, f != dist; rotate(x)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node[f].father != dist) &#123;</span><br><span class="line">            <span class="keyword">if</span>(check(x) == check(f)) &#123;</span><br><span class="line">                rotate(f); <span class="comment">//方向一致则旋转x的父节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rotate(x); <span class="comment">//方向不一致则旋转x</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist == <span class="number">0</span>) &#123;</span><br><span class="line">        root = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>查找值为x的节点，找到后将其置为<code>root</code>以便操作。</p><p><code>find</code>操作的意义在于将值为x的节点伸展（splay）到根，在不存在值为x的节点的情况下，应将小于x的节点中最大的节点伸展（splay）到根。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = root;</span><br><span class="line">    <span class="keyword">while</span>(node[cur].ch[x &gt; node[cur].v] != <span class="number">0</span> &amp;&amp; x != node[cur].v) &#123;</span><br><span class="line">        cur = node[cur].ch[x &gt; node[cur].v]; <span class="comment">//查找值为x的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    splay(cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公共操作"><a href="#公共操作" class="headerlink" title="公共操作"></a>公共操作</h2><p>如果将本文讲的Splay打包成一个<code>class</code>，则前文所述的操作应包含在<code>private</code>中，本节所述的操作应包含在<code>public</code>中。</p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>Splay中的<code>insert</code>其实与朴素BST中的<code>insert</code>没有什么区别，但若直接插入可能导致树退化为链，所以要在末尾处调用一次splay()函数，使Splay树保持平衡。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = root, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="number">0</span> &amp;&amp; node[cur].v != x) &#123;</span><br><span class="line">        p = cur;</span><br><span class="line">        cur = node[cur].ch[x &lt; node[cur].v ? <span class="number">0</span> : <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur != <span class="number">0</span>) &#123;</span><br><span class="line">        node[cur].cnt++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur = ++cnt;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="number">0</span>) &#123;</span><br><span class="line">            node[p].ch[x &lt;= node[p].v ? <span class="number">0</span> : <span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        node[cur] = Node(x, p, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    splay(cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="serial"><a href="#serial" class="headerlink" title="serial"></a>serial</h3><p><code>serial</code>操作：查询值为x的节点，在<code>find</code>操作的基础上，<code>serial</code>只需要在<code>find</code>过后输出左子树节点数量即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serial</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    find(x);</span><br><span class="line">    <span class="keyword">return</span> node[node[root].ch[<span class="number">0</span>]].size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pre"><a href="#pre" class="headerlink" title="pre"></a>pre</h3><p>找出值为x的节点的前驱，将节点splay到root后在左子树查找最大值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    find(x);</span><br><span class="line">    <span class="keyword">if</span>(node[root].v &lt; x) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur = node[root].ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(node[cur].ch[<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        cur = node[cur].ch[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="suc"><a href="#suc" class="headerlink" title="suc"></a>suc</h3><p>找出值为x的点的后继，与前驱同理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">suc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    find(x);</span><br><span class="line">    <span class="keyword">if</span>(node[root].v &gt; x) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur = node[root].ch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(node[cur].ch[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        cur = node[cur].ch[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>删除一个节点。</p><p>删除较为复杂，分四步来完成：</p><ol><li>定义<code>last</code>为节点的前驱，<code>next</code>为节点的后继。</li><li>将<code>last</code>节点splay到<code>root</code>，这时<code>last</code>的左子树皆小于x</li><li>将<code>next</code>节点splay到<code>last</code>的子节右点，此时<code>next</code>的右子树皆大于x</li><li><code>next</code>的左节点<code>rm</code>必然满足 <code>last</code> &lt; rm &lt; <code>next</code>，删除<code>rm</code>即可</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = pre(x), next = suc(x);</span><br><span class="line">    splay(last);</span><br><span class="line">    splay(next, last);</span><br><span class="line">    <span class="keyword">int</span> rm = node[next].ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(node[rm].cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        node[rm].cnt--;</span><br><span class="line">        splay(rm);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node[next].ch[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        pushup(next);</span><br><span class="line">        pushup(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rank"><a href="#rank" class="headerlink" title="rank"></a>rank</h3><p>查找排名为k的节点</p><p>用一个指针cur从root开始查找，每次根据左子树大小于k的关系修改cur以及k。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node[cur].ch[<span class="number">0</span>] != <span class="number">0</span> &amp;&amp; k &lt;= node[node[cur].ch[<span class="number">0</span>]].size) &#123;</span><br><span class="line">            cur = node[cur].ch[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; node[node[cur].ch[<span class="number">0</span>]].size + node[cur].cnt) &#123;</span><br><span class="line">            k -= node[node[cur].ch[<span class="number">0</span>]].size + node[cur].cnt;</span><br><span class="line">            cur = node[cur].ch[<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zh.wikipedia.org/zh-hans/伸展树" target="_blank" rel="noopener">伸展树- 维基百科，自由的百科全书</a></p><p><a href="https://www.youtube.com/watch?v=IBY4NtxmGg8" target="_blank" rel="noopener">Splay Tree Introduction</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一维数据结构学习笔记</title>
      <link href="/archives/1580237458/"/>
      <url>/archives/1580237458/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一维数据结构学习笔记"><a href="#一维数据结构学习笔记" class="headerlink" title="一维数据结构学习笔记"></a>一维数据结构学习笔记</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表:按顺序记录元素的线性数据结构。</p><p>其中的“顺序”是逻辑上的顺序，不一定是物理存储上的顺序。</p><p>链表分为单向与双向两种：</p><p>1.单向链表:每个元素只记录了下一个元素的位置。</p><p>2.双向链表:每个元素记录了上一个及下一个元素的位置。</p><p>代码实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用类来定义链表中的每个元素。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">    Node * next = <span class="literal">NULL</span>, * prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*前一个元素或者后一个元素可以不存在，所以必须要使用指针类型。*/</span></span><br><span class="line">    </span><br><span class="line">    Node(<span class="keyword">int</span> v = <span class="number">0</span>, Node * next = <span class="literal">NULL</span>, Node * prev = <span class="literal">NULL</span>):v(v), next(next), prev(prev) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="链表常用操作-构造链表"><a href="#链表常用操作-构造链表" class="headerlink" title="链表常用操作:构造链表"></a>链表常用操作:构造链表</h3><p>通过实例化链表类，创建链表的每个元素并建立元素之间的关系。</p><p>代码实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个只有头尾两个元素的链表。</span></span><br><span class="line">Node* head = <span class="keyword">new</span> Node(); </span><br><span class="line">Node* tail = <span class="keyword">new</span> Node(); </span><br><span class="line"></span><br><span class="line">head -&gt; next = tail;</span><br><span class="line">tile -&gt; prev = head;</span><br></pre></td></tr></table></figure></p><h3 id="链表常用操作-遍历链表"><a href="#链表常用操作-遍历链表" class="headerlink" title="链表常用操作:遍历链表"></a>链表常用操作:遍历链表</h3><p>将链表头赋值给临时变量，然后不断寻找下一个元素直到空。</p><p>代码实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node* i = head;</span><br><span class="line"><span class="keyword">while</span> (i -&gt; next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    i = i -&gt; next;</span><br><span class="line">    <span class="comment">//需要对链表元素进行的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="链表常用操作-插入元素"><a href="#链表常用操作-插入元素" class="headerlink" title="链表常用操作:插入元素"></a>链表常用操作:插入元素</h3><p>找到要插入元素的位置，一般是记录前一个元素。<br>重新设置插入位置两边的元素和插入元素的关系。</p><p>代码实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在元素p后面插入元素i</span></span><br><span class="line">i -&gt; next = p -&gt; next;</span><br><span class="line">i -&gt; prev = p;</span><br><span class="line"><span class="keyword">if</span> (p -&gt; next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    p -&gt; next -&gt; prev = i;</span><br><span class="line">&#125;</span><br><span class="line">p -&gt; next = i;</span><br></pre></td></tr></table></figure></p><p>注意:</p><blockquote><p>1.修改关系的顺序.</p><p>2.特判插入链表头的情况。</p></blockquote><h3 id="链表常用操作-删除元素"><a href="#链表常用操作-删除元素" class="headerlink" title="链表常用操作:删除元素"></a>链表常用操作:删除元素</h3><p>首先，找到要删除的元素。</p><p>重新设置该元素的前后元素之间的关系，并根据需要释放元素。<br>代码实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i -&gt; next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    i -&gt; next -&gt; prev = i -&gt; prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i -&gt; prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    i -&gt; prev -&gt; next = i -&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> i;</span><br></pre></td></tr></table></figure></p><p>注意:</p><blockquote><p>如果有变量用来记录链表头，头被删除时要记得更新。</p><p>链表尾同理。</p></blockquote><h3 id="链表-Q-amp-A"><a href="#链表-Q-amp-A" class="headerlink" title="链表 Q&amp;A"></a>链表 Q&amp;A</h3><p><strong>Q：</strong> 单向链表可以进行删除元素操作吗?</p><p><strong>A：</strong> 可以。通过预判下一个元素的方式，找到要删除元素的上一个元素，再更新下一个元素。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pr -&gt; next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    pr -&gt; next = pr -&gt; next -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，还是要特判删除链表头的情况。</p><p><strong>Q：</strong> 还有别的方式可以用来实现链表吗?</p><p><strong>A：</strong> 通常情况下，使用数组来实现链表会更加简便。</p><p>给每个元素一个编号(地址)，以代替指针的引用。</p><p>为了记录每个元素的属性，可以使用结构体、二维数组或者多个数组。</p><p><strong>Q：</strong> 用数组实现链表有哪些缺点?</p><p><strong>A：</strong> 1.数组必须一次性初始化，并且长度固定。2.删除元素不会真正的释放空间。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>从严格意义上来说，队列是一种特殊的链表，只支持添加队列尾元素和删除队列头元素两种操作。</p><p>或者说，队列是链表的子集。</p><h3 id="队列常用操作-从队列尾部添加元素"><a href="#队列常用操作-从队列尾部添加元素" class="headerlink" title="队列常用操作:从队列尾部添加元素"></a>队列常用操作:从队列尾部添加元素</h3><p>创建一个新元素，将队尾元素的下一个元素指向新元素。</p><p>将队尾移动到新元素。</p><p>代码实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node* newTail = <span class="keyword">new</span> Node();</span><br><span class="line">tail -&gt; next = newTail;</span><br><span class="line">tail = newTail;</span><br></pre></td></tr></table></figure></p><h3 id="队列常用操作-从队列头部删除元素"><a href="#队列常用操作-从队列头部删除元素" class="headerlink" title="队列常用操作:从队列头部删除元素"></a>队列常用操作:从队列头部删除元素</h3><p>记录队头元素。</p><p>将队头元素移动到它的下一个元素。根据需要释放旧的队头元素。</p><p>代码实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node* oldHead = head;</span><br><span class="line">head = head -&gt; next;</span><br><span class="line">oldHead -&gt; next = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p><p>注意：</p><blockquote><p>还要特判队列为空的情况。</p></blockquote><h3 id="数组-一种特殊的队列"><a href="#数组-一种特殊的队列" class="headerlink" title="数组:一种特殊的队列"></a>数组:一种特殊的队列</h3><p>用两个整数表示数组的下标，作为队头和队尾的指针。</p><p>删除元素则将队头指针+1，添加元素则将队尾指针+1。</p><p>队头指针超过的队尾指针表示队列为空。</p><h3 id="循环队列-循环重复利用被删除空间的数组队列"><a href="#循环队列-循环重复利用被删除空间的数组队列" class="headerlink" title="循环队列:循环重复利用被删除空间的数组队列"></a>循环队列:循环重复利用被删除空间的数组队列</h3><p>移动指针后如果超出了数组长度，则重置为0。</p><p>当尾指针追赶上头指针时，表示队列溢出。</p><p>定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LENGTH = <span class="number">100</span>;</span><br><span class="line">Node* <span class="built_in">queue</span>[LENGTH];</span><br><span class="line"><span class="keyword">int</span> head = <span class="number">0</span>, tile = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>添加元素：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(Node* t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head != (tail + <span class="number">2</span>)) &#123; <span class="comment">// 判断满。 </span></span><br><span class="line">        tail = (tail + <span class="number">1</span>) % LENGTH; </span><br><span class="line">        <span class="built_in">queue</span>[tail] = t;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>删除元素：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head != (tail + <span class="number">1</span>)) &#123; <span class="comment">// 判断空。 </span></span><br><span class="line">        Node* h = <span class="built_in">queue</span>[head];</span><br><span class="line">        head = (head + <span class="number">1</span>) % LENGTH;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="队列-Q-amp-A"><a href="#队列-Q-amp-A" class="headerlink" title="队列 Q&amp;A"></a>队列 Q&amp;A</h3><p><strong>Q：</strong> 队列是单向链表还是双向链表?</p><p><strong>A：</strong> 使用单向链表足以支持队列的操作。</p><p><strong>Q：</strong> 如果是双向队列，需要额外增加哪些操作?</p><p><strong>A：</strong> 添加时要设置新元素的前一个元素，删除时要清空新队头的前一个元素。</p><p><strong>Q：</strong> 数组队列有哪些优点与缺点?</p><p><strong>A：</strong> 优点：队列不需要删除中间元素，数组完全满足队列的操作要求。</p><p>缺点：删除掉的空间无法被重复利用。</p><p><strong>Q：</strong> 如何区分循环队列是满还是空?</p><p><strong>A：</strong> 有两种方案：</p><blockquote><p>1.用一个额外的变量记录队列的元素个数。</p><p>2.将实际队列的容量变为数组长度-1，让队列空和满时的队尾指针在不同的位置。</p></blockquote><p>本文代码采用的是第二种方案</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>从严格意义上来说栈是一种特殊的链表，只支持添加栈尾元素和删除栈尾元素两种操作。</p><p>或者说，栈是链表的子集。</p><h3 id="栈常用操作-从栈尾部添加元素"><a href="#栈常用操作-从栈尾部添加元素" class="headerlink" title="栈常用操作:从栈尾部添加元素"></a>栈常用操作:从栈尾部添加元素</h3><p>1.创建一个新元素。<br>2.将新元素的上一个元素指向栈尾元素。<br>3.将栈尾移动到新元素。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node* newTail = <span class="keyword">new</span> Node();</span><br><span class="line">newTail -&gt; prev = tail;</span><br><span class="line">tail = newTail;</span><br></pre></td></tr></table></figure></p><p>注意：还要特判栈为空的情况。</p><h3 id="栈常用操作-从栈尾部删除元素"><a href="#栈常用操作-从栈尾部删除元素" class="headerlink" title="栈常用操作:从栈尾部删除元素"></a>栈常用操作:从栈尾部删除元素</h3><p>1.记录栈尾元素。<br>2.将栈尾元素移动到它的上一个元素。<br>3.将旧栈尾元素的上一个元素置空。根据需要释放旧的栈尾元素。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node* oldTail = tail;</span><br><span class="line">tail = tail -&gt; prev;</span><br><span class="line">oldTail -&gt; prev = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p><p>注意：还要特判栈为空的情况。</p><h3 id="数组-一种特殊的栈"><a href="#数组-一种特殊的栈" class="headerlink" title="数组:一种特殊的栈"></a>数组:一种特殊的栈</h3><p>用一个整数表示数组的下标，作为栈尾的指针。</p><p>添加元素则将栈尾指针+1，删除元素则将栈尾指针-1。</p><p>栈尾指针小于栈头元素的下标则表示栈为空。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷题解P1119【灾后重建】</title>
      <link href="/archives/1827780785/"/>
      <url>/archives/1827780785/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>$B$地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出$B$地区的村庄数$N$，村庄编号从$0$到$N-1$，和所有$M$条公路的长度，公路是双向的。并给出第$i$个村庄重建完成的时间$t_i$，你可以认为是同时开始重建并在第$t_i$天重建完成，并且在当天即可通车。若$t_i$为$0$则说明地震未对此地区造成损坏，一开始就可以通车。之后有$Q$个询问$(x, y, t)$，对于每个询问你要回答在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少。如果无法找到从$x$村庄到$y$村庄的路径，经过若干个已重建完成的村庄，或者村庄$x$或村庄$y$在第$t$天仍未重建完成 ，则需要返回$-1$。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>第一行包含两个正整数$N,M$，表示了村庄的数目与公路的数量。</p><p>第二行包含$N$个非负整数$t_0, t_1,…, t_{N-1}$​，表示了每个村庄重建完成的时间，数据保证了$t_0 ≤ t_1 ≤ … ≤ t_{N-1}​$。</p><p>接下来$M$行，每行$3$个非负整数$i, j, w$，$w$为不超过$10000$的正整数，表示了有一条连接村庄$i$与村庄$j$的道路，长度为$w$，保证$i≠j$，且对于任意一对村庄只会存在一条道路。</p><p>接下来一行也就是$M+3$行包含一个正整数$Q$，表示$Q$个询问。</p><p>接下来$Q$行，每行$3$个非负整数$x, y, t$，询问在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少，数据保证了$t$是不下降的。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>共$Q$行，对每一个询问$(x, y, t)$输出对应的答案，即在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少。如果在第$t$天无法找到从$x$村庄到$y$村庄的路径，经过若干个已重建完成的村庄，或者村庄$x$或村庄$y$在第$t$天仍未修复完成，则输出$-1$。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h2><p>4 5<br>1 2 3 4<br>0 2 1<br>2 3 1<br>3 1 2<br>2 1 4<br>0 3 5<br>4<br>2 0 2<br>0 1 2<br>0 1 3<br>0 1 4</p><h2 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h2><p>-1<br>-1<br>5<br>4</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>对于$30\%$的数据，有$N≤50$；</p><p>对于$30\%$的数据，有$t_i= 0$，其中有20\%20%的数据有$t_i = 0$且$N&gt;50$；</p><p>对于$50\%$的数据，有$Q≤100$；</p><p>对于$100\%$的数据，有$N≤200$，$M≤N \times (N-1)/2$，$Q≤50000$，所有输入数据涉及整数均不超过$100000$。</p><h1 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h1><p>本题基本上是Floyd的模版题，适合初学Floyd的OIer练习。</p><p>本题的重点在于并非在每一个时刻，每一个节点都可以到达，所以应枚举目前所有可以到达的节点k，并以k为中转点进行更新。</p><p>同时，因为出题人已经给数据排好了顺序，发现未建成时直接中断即可。</p><p>闲话少说，主要看代码注释。</p><p>#代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge[MAXN][MAXN], times[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">init()函数：</span></span><br><span class="line"><span class="comment">Floyd初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">edge[i][j] = (i == j ? <span class="number">0</span> : INF);<span class="comment">//节点到自身的距离为0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">addEdge()函数：</span></span><br><span class="line"><span class="comment">在邻接矩阵中添加一条（双向）边</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[i][j] = edge[j][i] = v;<span class="comment">//双向边处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">input()函数：</span></span><br><span class="line"><span class="comment">输入数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">init(); <span class="comment">//读入n, m后进行初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;times[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y, v;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;v);</span><br><span class="line">addEdge(x, y, v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">update()函数：</span></span><br><span class="line"><span class="comment">以k为中转点更新最短路</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">edge[i][j] = min(edge[i][j], edge[i][k] + edge[k][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y, t;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;t);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//这里是重点</span></span><br><span class="line"><span class="keyword">while</span>(times[cur] &lt;= t &amp;&amp; cur &lt; n) &#123;</span><br><span class="line">update(cur);<span class="comment">//若当前可以经过村庄cur，以cur为中转点更新最短路径</span></span><br><span class="line">                        cur++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(times[x] &gt; t || times[y] &gt; t || edge[x][y] == INF) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n"</span>);<span class="comment">//村庄x尚未建成,村庄x尚未建成或村庄x与村庄y在t时并不连通</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, edge[x][y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">//简洁的main()函数</span></span><br><span class="line">input();</span><br><span class="line">work();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2018游记</title>
      <link href="/archives/3769932704/"/>
      <url>/archives/3769932704/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="出师"><a href="#出师" class="headerlink" title="出师"></a>出师</h1><p>（1）</p><p>起床看见洛谷首页上显示的“距NOIP2018还有-1天”时，差点把嘴里的一口早饭喷了出来。</p><p>不过又想一下，要是一大早看见个“距NOIP2019还有365天”，估计瞬间会感觉压力山大。。。</p><p>(2)</p><p>进考场前竟然下起了倾盆大雨，从地铁站出来后，举着伞转了一个小时才找到考场，期间不停的被地图坑。</p><p>（我才不会告诉你浪费这么多时间的真正原因是使用迭代加深搜索找考场。）</p><p>进了考场发现有惊喜。。。机房竟然有网！有网！<del>结果在考试前网断了。。。</del>然后开始调整编辑器，<del>以至于没注意到别人都开始打代码了。。。</del></p><h1 id="第一题，水题，鉴定完毕。"><a href="#第一题，水题，鉴定完毕。" class="headerlink" title="第一题，水题，鉴定完毕。"></a>第一题，<del>水题，鉴定完毕。</del></h1><p>分析：可能连模拟都算不上，直接从头到尾扫描一遍即可。</p><p>但虽说是水题，也有一些坑点：</p><ol><li><p>读入要用 string + cin + getline()!</p><p> 读入要用 string + cin + getline()!</p><p> 读入要用 string + cin + getline()!</p><p> 重要的事情说三遍！</p><p> @垃圾一个 就是在这一点上炸了。</p></li><li><p>判断时要自编函数或alnum，不能用ctype.h中的isprint()函数，要用isalnum()函数。</p><p> 如果你问”isprint()函数是什么”或”isalnum()函数是什么”,请自行忽略这段话并自觉编写判断函数。</p><p> 别问我为什么，Luogu自测只有20分。</p></li></ol><p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    getline(<span class="built_in">cin</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(check(s[i])) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="第二题，暴力枚举，鉴定完毕。"><a href="#第二题，暴力枚举，鉴定完毕。" class="headerlink" title="第二题，暴力枚举，鉴定完毕。"></a>第二题，<del>暴力枚举，鉴定完毕。</del></h1><p>分析：</p><ol><li><p>先计算好每一个军营的气势，同时累加双方的气势总和（输入后处理）</p></li><li><p>枚举每一个军营，检查若将工兵放在此位置是否可减少双方差距，并更新最小值与位置。</p></li><li><p><del>输出位置</del></p></li></ol><p>写第一遍时大概思路就酱。</p><p>运行结果：</p><p>样例#1:Pass</p><p>样例#1:Pass</p><p>样例#3:<br><strong>Beng!</strong></p><p>又看了一下数据范围，对于 100% 的数据，n ≤ 10 ^ 5,ci,s1,s2≤10^9。</p><p>10^9?</p><p>“十年OI一场空，没开long long 见祖宗”，这话果然没错。</p><p>除int main()外的所有int皆换成long long，OK。</p><p>PS:如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//some code</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之类的旁门左道，为了安全起见，大家不要滥用哦QwQ。<del>有本事你写个typedef int long long看报不报错</del></p><h1 id="第三题。。。"><a href="#第三题。。。" class="headerlink" title="第三题。。。"></a>第三题。。。</h1><p>我这种小蒟蒻怎么可能作对前三题呢QwQ,又怎么可能想到DP正解QwQ</p><p>所以我挥手打了贪心。。。<del>当我发现第三个样例没过时已经来不及了</del></p><p>先说说贪心具体思路：</p><ol><li>将学生按照到达时间从小到大排个序</li><li>用一个光标变量记录目前接到了第几个学生，如果还有人没被接到，就继续循环知道所有人都被接到为止。</li><li>每次循环时检查当前这个人是否值得带，若值得则将光标后移。</li><li>每次循环后将时间加上开车所需要的时间。</li><li>最后累加总等待时间并输出。</li></ol><p>答案正确率：玄学</p><p>到各大网站上测之，30分有之，80分有之，一切随缘。</p><h1 id="第四题本蒟蒻骗了分，没脸来这胡说了。。。"><a href="#第四题本蒟蒻骗了分，没脸来这胡说了。。。" class="headerlink" title="第四题本蒟蒻骗了分，没脸来这胡说了。。。"></a>第四题本蒟蒻骗了分，没脸来这胡说了。。。</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>咳咳咳。。。</p><h2 id="1-考试策略的应用"><a href="#1-考试策略的应用" class="headerlink" title="(1)考试策略的应用"></a>(1)考试策略的应用</h2><p>亏得我这只小蒟蒻还在进考场前看了1h AK NOI 的各位dalao 呕心沥血写的各种考场策略，结果一进考场简直就像接受了A级记忆删除，什么都忘得一干二净：</p><ol><li>一，二题打完过了样例就去打第三题。（double-plus-scared）</li><li>第三题贪心死活过不了第三个点还执迷不悟认为就是贪心。</li><li>第四题明明有子任务放着不做打随机数。</li></ol><h2 id="2-考场心态的调整"><a href="#2-考场心态的调整" class="headerlink" title="(2)考场心态的调整"></a>(2)考场心态的调整</h2><p>众所周知，在NOIP考场这种地方要想保持心态稳定是不可能的。然而如果吓得完全写不出代码就凉凉了。总结就是一定要冷静冷静冷静再冷静，一定不要像某人一样，贪心错了都想不到半个动规。</p><p>最后，祝大家：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(NOIP2019.rp &lt; NOIP2019.rp + <span class="number">1</span>) &#123;</span><br><span class="line">    NOIP2019.rp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>New Start</title>
      <link href="/archives/3735749857/"/>
      <url>/archives/3735749857/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>折腾一番后终于把之前的文章迁移到GitHub Pages + Hexo的博客上了，之所以选择GitHub是因为这个平台忽然关闭的可能性很小，并且可定制性极强，虽然只能做静态网页，但搭个博客还是绰绰有余的。</p><p>从另一方面来讲，GitHub的信誉也不错，在服务品质上也比国内的诸多流氓公司强得多。</p><a id="more"></a><p>扯了这么多，博客的本质还是发布文章，就看自己能否坚持写下去了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/googled6f21b45cb6d05ea.html"/>
      <url>/googled6f21b45cb6d05ea.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=UTF-8"></head><body>google-site-verification: googled6f21b45cb6d05ea.html</body></html>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/true/index.html"/>
      <url>/true/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/404/index.html"/>
      <url>/404/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><!DOCTYPE HTML><html><head><meta name="generator" content="Hexo 3.8.0">  <meta http-equiv="content-type" content="text/html;charset=utf-8;">  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">  <meta name="robots" content="all">  <meta name="robots" content="index,follow"></head><body><script type="text/javascript" src="http://www.qq.com/404/search_children.js" charset="utf-8" homepageurl="https://keepthethink.github.io" homepagename="回到我的主页"></script></body></html>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><center><br><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="510" height="86" src="//music.163.com/outchain/player?type=2&id=511333096&auto=0&height=66"></iframe><br></center><h2 id="About-Me"><a href="#About-Me" class="headerlink" title="About Me"></a>About Me</h2><p>一名信竞党，坐标HN</p><h2 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h2><h3 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h3><h4 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h4><p>2018.12 全国信息学奥林匹克联赛NOIP2018普及组湖南赛区一等奖</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>闲言碎语</title>
      <link href="/cross/index.html"/>
      <url>/cross/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="中医"><a href="#中医" class="headerlink" title="中医"></a>中医</h2><p>药理：不明</p><p>作用机制: 不明</p><p>疗效：不明</p><p>不良反应: 不明</p><p>临床研究: 暂无</p><p>禁忌: 不明</p><hr><h2 id="爱国者"><a href="#爱国者" class="headerlink" title="爱国者"></a>爱国者</h2><p>如果你觉得你的祖国不好，你就去建设它，如果你觉得政府不好，你就去考公务员去做官，如果你觉得人民没素质，就从你开始做一个高素质的公民，如果你觉得同胞愚昧无知，就从你开始学习并改变身边的人，而不是一昧的谩骂，抱怨，逃离。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><table><thead><tr><th>标题</th><th>链接</th></tr></thead><tbody><tr><td>Always Firmly on OI</td><td><a href="https://czyhe.me/" target="_blank" rel="noopener">https://czyhe.me/</a></td></tr><tr><td>memset0的博客</td><td><a href="https://memset0.cn/" target="_blank" rel="noopener">https://memset0.cn/</a></td></tr><tr><td>menci</td><td><a href="https://men.ci/" target="_blank" rel="noopener">https://men.ci/</a></td></tr><tr><td>雨宮千夏の博麗神社</td><td><a href="https://uuz.moe/" target="_blank" rel="noopener">https://uuz.moe/</a></td></tr><tr><td>_rqy’s Blog</td><td><a href="https://rqy.moe/" target="_blank" rel="noopener">https://rqy.moe/</a></td></tr><tr><td>Loner</td><td><a href="https://zhang-rq.github.io/" target="_blank" rel="noopener">https://zhang-rq.github.io/</a></td></tr></tbody></table>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>时间轴</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
  
</search>
